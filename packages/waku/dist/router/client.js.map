{"version":3,"sources":["../../src/router/client.ts"],"sourcesContent":["'use client';\n\nimport {\n  createContext,\n  createElement,\n  useCallback,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n  useTransition,\n  Fragment,\n  Component,\n} from 'react';\nimport type {\n  ComponentProps,\n  FunctionComponent,\n  ReactNode,\n  AnchorHTMLAttributes,\n  ReactElement,\n  MouseEvent,\n} from 'react';\n\nimport {\n  prefetchRsc,\n  Root,\n  Slot,\n  useRefetch,\n  ThrowError_UNSTABLE as ThrowError,\n  useResetError_UNSTABLE as useResetError,\n} from '../minimal/client.js';\nimport {\n  encodeRoutePath,\n  ROUTE_ID,\n  IS_STATIC_ID,\n  HAS404_ID,\n  SKIP_HEADER,\n} from './common.js';\nimport type { RouteProps } from './common.js';\nimport type { RouteConfig } from './base-types.js';\nimport { getErrorInfo } from '../lib/utils/custom-errors.js';\n\ntype AllowPathDecorators<Path extends string> = Path extends unknown\n  ? Path | `${Path}?${string}` | `${Path}#${string}`\n  : never;\n\ntype InferredPaths = RouteConfig extends {\n  paths: infer UserPaths extends string;\n}\n  ? AllowPathDecorators<UserPaths>\n  : string;\n\ndeclare global {\n  interface ImportMeta {\n    readonly env: Record<string, string>;\n  }\n}\n\nconst normalizeRoutePath = (path: string) => {\n  for (const suffix of ['/', '/index.html']) {\n    if (path.endsWith(suffix)) {\n      return path.slice(0, -suffix.length) || '/';\n    }\n  }\n  return path;\n};\n\nconst parseRoute = (url: URL): RouteProps => {\n  const { pathname, searchParams, hash } = url;\n  return {\n    path: normalizeRoutePath(pathname),\n    query: searchParams.toString(),\n    hash,\n  };\n};\n\nconst parseRouteFromLocation = (): RouteProps => {\n  if ((globalThis as any).__WAKU_ROUTER_404__) {\n    return { path: '/404', query: '', hash: '' };\n  }\n  return parseRoute(new URL(window.location.href));\n};\n\nlet savedRscParams: [query: string, rscParams: URLSearchParams] | undefined;\n\nconst createRscParams = (query: string): URLSearchParams => {\n  if (savedRscParams && savedRscParams[0] === query) {\n    return savedRscParams[1];\n  }\n  const rscParams = new URLSearchParams({ query });\n  savedRscParams = [query, rscParams];\n  return rscParams;\n};\n\ntype ChangeRoute = (\n  route: RouteProps,\n  options: {\n    shouldScroll: boolean;\n    skipRefetch?: boolean;\n  },\n) => void;\n\ntype PrefetchRoute = (route: RouteProps) => void;\n\nconst RouterContext = createContext<{\n  route: RouteProps;\n  changeRoute: ChangeRoute;\n  prefetchRoute: PrefetchRoute;\n} | null>(null);\n\nexport function useRouter_UNSTABLE() {\n  const router = useContext(RouterContext);\n  if (!router) {\n    throw new Error('Missing Router');\n  }\n  const { route, changeRoute, prefetchRoute } = router;\n  const push = useCallback(\n    (\n      to: InferredPaths,\n      options?: {\n        /**\n         * indicates if the link should scroll or not on navigation\n         * - `true`: always scroll\n         * - `false`: never scroll\n         * - `undefined`: scroll on path change (not on searchParams change)\n         */\n        scroll?: boolean;\n      },\n    ) => {\n      const url = new URL(to, window.location.href);\n      const newPath = url.pathname !== window.location.pathname;\n      window.history.pushState(\n        {\n          ...window.history.state,\n          waku_new_path: newPath,\n        },\n        '',\n        url,\n      );\n      changeRoute(parseRoute(url), {\n        shouldScroll: options?.scroll ?? newPath,\n      });\n    },\n    [changeRoute],\n  );\n  const replace = useCallback(\n    (\n      to: InferredPaths,\n      options?: {\n        /**\n         * indicates if the link should scroll or not on navigation\n         * - `true`: always scroll\n         * - `false`: never scroll\n         * - `undefined`: scroll on path change (not on searchParams change)\n         */\n        scroll?: boolean;\n      },\n    ) => {\n      const url = new URL(to, window.location.href);\n      const newPath = url.pathname !== window.location.pathname;\n      window.history.replaceState(window.history.state, '', url);\n      changeRoute(parseRoute(url), {\n        shouldScroll: options?.scroll ?? newPath,\n      });\n    },\n    [changeRoute],\n  );\n  const reload = useCallback(() => {\n    const url = new URL(window.location.href);\n    changeRoute(parseRoute(url), { shouldScroll: true });\n  }, [changeRoute]);\n  const back = useCallback(() => {\n    // FIXME is this correct?\n    window.history.back();\n  }, []);\n  const forward = useCallback(() => {\n    // FIXME is this correct?\n    window.history.forward();\n  }, []);\n  const prefetch = useCallback(\n    (to: string) => {\n      const url = new URL(to, window.location.href);\n      prefetchRoute(parseRoute(url));\n    },\n    [prefetchRoute],\n  );\n  return {\n    ...route,\n    push,\n    replace,\n    reload,\n    back,\n    forward,\n    prefetch,\n  };\n}\n\nexport type LinkProps = {\n  to: InferredPaths;\n  children: ReactNode;\n  /**\n   * indicates if the link should scroll or not on navigation\n   * - `true`: always scroll\n   * - `false`: never scroll\n   * - `undefined`: scroll on path change (not on searchParams change)\n   */\n  scroll?: boolean;\n  unstable_pending?: ReactNode;\n  unstable_notPending?: ReactNode;\n  unstable_prefetchOnEnter?: boolean;\n  unstable_prefetchOnView?: boolean;\n  unstable_startTransition?: ((fn: () => void) => void) | undefined;\n} & Omit<AnchorHTMLAttributes<HTMLAnchorElement>, 'href'>;\n\nexport function Link({\n  to,\n  children,\n  scroll,\n  unstable_pending,\n  unstable_notPending,\n  unstable_prefetchOnEnter,\n  unstable_prefetchOnView,\n  unstable_startTransition,\n  ...props\n}: LinkProps): ReactElement {\n  const router = useContext(RouterContext);\n  const changeRoute = router\n    ? router.changeRoute\n    : () => {\n        throw new Error('Missing Router');\n      };\n  const prefetchRoute = router\n    ? router.prefetchRoute\n    : () => {\n        throw new Error('Missing Router');\n      };\n  const [isPending, startTransition] = useTransition();\n  const startTransitionFn =\n    unstable_startTransition ||\n    ((unstable_pending || unstable_notPending) && startTransition) ||\n    ((fn: () => void) => fn());\n  const ref = useRef<HTMLAnchorElement>(undefined);\n\n  useEffect(() => {\n    if (unstable_prefetchOnView && ref.current) {\n      const observer = new IntersectionObserver(\n        (entries) => {\n          entries.forEach((entry) => {\n            if (entry.isIntersecting) {\n              const url = new URL(to, window.location.href);\n              if (router && url.href !== window.location.href) {\n                const route = parseRoute(url);\n                router.prefetchRoute(route);\n              }\n            }\n          });\n        },\n        { threshold: 0.1 },\n      );\n\n      observer.observe(ref.current);\n\n      return () => {\n        observer.disconnect();\n      };\n    }\n  }, [unstable_prefetchOnView, router, to]);\n  const onClick = (event: MouseEvent<HTMLAnchorElement>) => {\n    event.preventDefault();\n    const url = new URL(to, window.location.href);\n    if (url.href !== window.location.href) {\n      const route = parseRoute(url);\n      prefetchRoute(route);\n      startTransitionFn(() => {\n        const newPath = url.pathname !== window.location.pathname;\n        window.history.pushState(\n          {\n            ...window.history.state,\n            waku_new_path: newPath,\n          },\n          '',\n          url,\n        );\n        changeRoute(route, { shouldScroll: scroll ?? newPath });\n      });\n    }\n    props.onClick?.(event);\n  };\n  const onMouseEnter = unstable_prefetchOnEnter\n    ? (event: MouseEvent<HTMLAnchorElement>) => {\n        const url = new URL(to, window.location.href);\n        if (url.href !== window.location.href) {\n          const route = parseRoute(url);\n          prefetchRoute(route);\n        }\n        props.onMouseEnter?.(event);\n      }\n    : props.onMouseEnter;\n  const ele = createElement(\n    'a',\n    { ...props, href: to, onClick, onMouseEnter, ref },\n    children,\n  );\n  if (isPending && unstable_pending !== undefined) {\n    return createElement(Fragment, null, ele, unstable_pending);\n  }\n  if (!isPending && unstable_notPending !== undefined) {\n    return createElement(Fragment, null, ele, unstable_notPending);\n  }\n  return ele;\n}\n\nconst notAvailableInServer = (name: string) => () => {\n  throw new Error(`${name} is not in the server`);\n};\n\nfunction renderError(message: string) {\n  return createElement(\n    'html',\n    null,\n    createElement('body', null, createElement('h1', null, message)),\n  );\n}\n\nexport class ErrorBoundary extends Component<\n  { children: ReactNode },\n  { error?: unknown }\n> {\n  constructor(props: { children: ReactNode }) {\n    super(props);\n    this.state = {};\n  }\n  static getDerivedStateFromError(error: unknown) {\n    return { error };\n  }\n  render() {\n    if ('error' in this.state) {\n      if (this.state.error instanceof Error) {\n        return renderError(this.state.error.message);\n      }\n      return renderError(String(this.state.error));\n    }\n    return this.props.children;\n  }\n}\n\nconst NotFound = ({\n  has404,\n  reset,\n}: {\n  has404: boolean;\n  reset: () => void;\n}) => {\n  const resetError = useResetError();\n  const router = useContext(RouterContext);\n  if (!router) {\n    throw new Error('Missing Router');\n  }\n  const { changeRoute } = router;\n  useEffect(() => {\n    if (has404) {\n      const url = new URL('/404', window.location.href);\n      changeRoute(parseRoute(url), { shouldScroll: true });\n      resetError?.();\n      reset();\n    }\n  }, [has404, resetError, reset, changeRoute]);\n  return has404 ? null : createElement('h1', null, 'Not Found');\n};\n\nconst Redirect = ({ to, reset }: { to: string; reset: () => void }) => {\n  const resetError = useResetError();\n  const router = useContext(RouterContext);\n  if (!router) {\n    throw new Error('Missing Router');\n  }\n  const { changeRoute } = router;\n  useEffect(() => {\n    const url = new URL(to, window.location.href);\n    // FIXME this condition seems too naive\n    if (url.hostname !== window.location.hostname) {\n      window.location.replace(to);\n      return;\n    }\n    const newPath = url.pathname !== window.location.pathname;\n    window.history.pushState(\n      {\n        ...window.history.state,\n        waku_new_path: newPath,\n      },\n      '',\n      url,\n    );\n    changeRoute(parseRoute(url), { shouldScroll: newPath });\n    resetError?.();\n    reset();\n  }, [to, resetError, reset, changeRoute]);\n  return null;\n};\n\nclass CustomErrorHandler extends Component<\n  { has404: boolean; children?: ReactNode },\n  { error: unknown | null }\n> {\n  constructor(props: { has404: boolean; children?: ReactNode }) {\n    super(props);\n    this.state = { error: null };\n    this.reset = this.reset.bind(this);\n  }\n  static getDerivedStateFromError(error: unknown) {\n    return { error };\n  }\n  reset() {\n    this.setState({ error: null });\n  }\n  render() {\n    const { error } = this.state;\n    if (error !== null) {\n      const info = getErrorInfo(error);\n      if (info?.status === 404) {\n        return createElement(NotFound, {\n          has404: this.props.has404,\n          reset: this.reset,\n        });\n      }\n      if (info?.location) {\n        return createElement(Redirect, {\n          to: info.location,\n          reset: this.reset,\n        });\n      }\n      throw error;\n    }\n    return this.props.children;\n  }\n}\n\nconst getRouteSlotId = (path: string) => 'route:' + decodeURIComponent(path);\n\nconst handleScroll = () => {\n  const { hash } = window.location;\n  const { state } = window.history;\n  const element = hash && document.getElementById(hash.slice(1));\n  window.scrollTo({\n    left: 0,\n    top: element ? element.getBoundingClientRect().top + window.scrollY : 0,\n    behavior: state?.waku_new_path ? 'instant' : 'auto',\n  });\n};\n\nconst InnerRouter = ({\n  routerData,\n  initialRoute,\n}: {\n  routerData: Required<RouterData>;\n  initialRoute: RouteProps;\n}) => {\n  const [locationListeners, staticPathSet, , has404] = routerData;\n  const refetch = useRefetch();\n  const [route, setRoute] = useState(() => ({\n    // This is the first initialization of the route, and it has\n    // to ignore the hash, because on server side there is none.\n    // Otherwise there will be a hydration error.\n    // The client side route, including the hash, will be updated in the effect below.\n    ...initialRoute,\n    hash: '',\n  }));\n  // Update the route post-load to include the current hash.\n  useEffect(() => {\n    setRoute((prev) => {\n      if (\n        prev.path === initialRoute.path &&\n        prev.query === initialRoute.query &&\n        prev.hash === initialRoute.hash\n      ) {\n        return prev;\n      }\n      return initialRoute;\n    });\n  }, [initialRoute]);\n\n  const changeRoute: ChangeRoute = useCallback(\n    (route, options) => {\n      const { skipRefetch } = options || {};\n      if (!staticPathSet.has(route.path) && !skipRefetch) {\n        const rscPath = encodeRoutePath(route.path);\n        const rscParams = createRscParams(route.query);\n        refetch(rscPath, rscParams);\n      }\n      if (options.shouldScroll) {\n        handleScroll();\n      }\n      setRoute(route);\n    },\n    [refetch, staticPathSet],\n  );\n\n  const prefetchRoute: PrefetchRoute = useCallback(\n    (route) => {\n      if (staticPathSet.has(route.path)) {\n        return;\n      }\n      const rscPath = encodeRoutePath(route.path);\n      const rscParams = createRscParams(route.query);\n      prefetchRsc(rscPath, rscParams);\n      (globalThis as any).__WAKU_ROUTER_PREFETCH__?.(route.path);\n    },\n    [staticPathSet],\n  );\n\n  useEffect(() => {\n    const callback = () => {\n      const route = parseRoute(new URL(window.location.href));\n      changeRoute(route, { shouldScroll: true });\n    };\n    window.addEventListener('popstate', callback);\n    return () => {\n      window.removeEventListener('popstate', callback);\n    };\n  }, [changeRoute]);\n\n  useEffect(() => {\n    const callback = (path: string, query: string) => {\n      const url = new URL(window.location.href);\n      url.pathname = path;\n      url.search = query;\n      url.hash = '';\n      if (path !== '/404') {\n        window.history.pushState(\n          {\n            ...window.history.state,\n            waku_new_path: url.pathname !== window.location.pathname,\n          },\n          '',\n          url,\n        );\n      }\n      changeRoute(parseRoute(url), { skipRefetch: true, shouldScroll: false });\n    };\n    locationListeners.add(callback);\n    return () => {\n      locationListeners.delete(callback);\n    };\n  }, [changeRoute, locationListeners]);\n\n  const routeElement = createElement(Slot, { id: getRouteSlotId(route.path) });\n  const rootElement = createElement(\n    Slot,\n    {\n      id: 'root',\n      unstable_handleError: createElement(\n        CustomErrorHandler,\n        { has404 },\n        createElement(ThrowError),\n      ),\n    },\n    createElement(CustomErrorHandler, { has404 }, routeElement),\n  );\n  return createElement(\n    RouterContext.Provider,\n    { value: { route, changeRoute, prefetchRoute } },\n    rootElement,\n  );\n};\n\ntype Elements = Record<string, unknown>;\ntype EnhanceFetch = (fetchFn: typeof fetch) => typeof fetch;\ntype EnhanceCreateData = (\n  createData: (responsePromise: Promise<Response>) => Promise<Elements>,\n) => (responsePromise: Promise<Response>) => Promise<Elements>;\n\n// Note: The router data must be a stable mutable object (array).\ntype RouterData = [\n  locationListeners?: Set<(path: string, query: string) => void>,\n  staticPathSet?: Set<string>,\n  cachedIdSet?: Set<string>,\n  has404?: boolean,\n];\n\nconst DEFAULT_ROUTER_DATA: RouterData = [];\n\nexport function Router({\n  routerData = DEFAULT_ROUTER_DATA,\n  initialRoute = parseRouteFromLocation(),\n  unstable_enhanceFetch,\n  unstable_enhanceCreateData,\n}: {\n  routerData?: RouterData;\n  initialRoute?: RouteProps;\n  unstable_enhanceFetch?: EnhanceFetch;\n  unstable_enhanceCreateData?: EnhanceCreateData;\n}) {\n  const initialRscPath = encodeRoutePath(initialRoute.path);\n  const locationListeners = (routerData[0] ||= new Set());\n  const staticPathSet = (routerData[1] ||= new Set());\n  const cachedIdSet = (routerData[2] ||= new Set());\n  const enhanceFetch =\n    (fetchFn: typeof fetch) =>\n    (input: RequestInfo | URL, init: RequestInit = {}) => {\n      const skipStr = JSON.stringify(Array.from(cachedIdSet));\n      const headers = (init.headers ||= {});\n      if (Array.isArray(headers)) {\n        headers.push([SKIP_HEADER, skipStr]);\n      } else {\n        (headers as Record<string, string>)[SKIP_HEADER] = skipStr;\n      }\n      return fetchFn(input, init);\n    };\n  const enhanceCreateData =\n    (\n      createData: (\n        responsePromise: Promise<Response>,\n      ) => Promise<Record<string, unknown>>,\n    ) =>\n    async (responsePromise: Promise<Response>) => {\n      const data = createData(responsePromise);\n      Promise.resolve(data)\n        .then((data) => {\n          if (data && typeof data === 'object') {\n            const {\n              [ROUTE_ID]: routeData,\n              [IS_STATIC_ID]: isStatic,\n              [HAS404_ID]: has404,\n              ...rest\n            } = data;\n            if (routeData) {\n              const [path, query] = routeData as [string, string];\n              // FIXME this check here seems ad-hoc (less readable code)\n              if (\n                window.location.pathname !== path ||\n                (!isStatic &&\n                  window.location.search.replace(/^\\?/, '') !== query)\n              ) {\n                locationListeners.forEach((listener) => listener(path, query));\n              }\n              if (isStatic) {\n                staticPathSet.add(path);\n              }\n            }\n            if (has404) {\n              routerData[3] = true;\n            }\n            Object.keys(rest).forEach((id) => {\n              cachedIdSet.add(id);\n            });\n          }\n        })\n        .catch(() => {});\n      return data;\n    };\n  const initialRscParams = createRscParams(initialRoute.query);\n  return createElement(\n    Root as FunctionComponent<Omit<ComponentProps<typeof Root>, 'children'>>,\n    {\n      initialRscPath,\n      initialRscParams,\n      unstable_enhanceFetch: unstable_enhanceFetch\n        ? (fn) => unstable_enhanceFetch(enhanceFetch(fn))\n        : enhanceFetch,\n      unstable_enhanceCreateData: unstable_enhanceCreateData\n        ? (fn) => unstable_enhanceCreateData(enhanceCreateData(fn))\n        : enhanceCreateData,\n    },\n    createElement(InnerRouter, {\n      routerData: routerData as Required<RouterData>,\n      initialRoute,\n    }),\n  );\n}\n\n/**\n * ServerRouter for SSR\n * This is not a public API.\n */\nexport function INTERNAL_ServerRouter({ route }: { route: RouteProps }) {\n  const routeElement = createElement(Slot, { id: getRouteSlotId(route.path) });\n  const rootElement = createElement(\n    Slot,\n    { id: 'root', unstable_handleError: null },\n    routeElement,\n  );\n  return createElement(\n    Fragment,\n    null,\n    createElement(\n      RouterContext.Provider,\n      {\n        value: {\n          route,\n          changeRoute: notAvailableInServer('changeRoute'),\n          prefetchRoute: notAvailableInServer('prefetchRoute'),\n        },\n      },\n      rootElement,\n    ),\n  );\n}\n"],"names":["createContext","createElement","useCallback","useContext","useEffect","useRef","useState","useTransition","Fragment","Component","prefetchRsc","Root","Slot","useRefetch","ThrowError_UNSTABLE","ThrowError","useResetError_UNSTABLE","useResetError","encodeRoutePath","ROUTE_ID","IS_STATIC_ID","HAS404_ID","SKIP_HEADER","getErrorInfo","normalizeRoutePath","path","suffix","endsWith","slice","length","parseRoute","url","pathname","searchParams","hash","query","toString","parseRouteFromLocation","globalThis","__WAKU_ROUTER_404__","URL","window","location","href","savedRscParams","createRscParams","rscParams","URLSearchParams","RouterContext","useRouter_UNSTABLE","router","Error","route","changeRoute","prefetchRoute","push","to","options","newPath","history","pushState","state","waku_new_path","shouldScroll","scroll","replace","replaceState","reload","back","forward","prefetch","Link","children","unstable_pending","unstable_notPending","unstable_prefetchOnEnter","unstable_prefetchOnView","unstable_startTransition","props","isPending","startTransition","startTransitionFn","fn","ref","undefined","current","observer","IntersectionObserver","entries","forEach","entry","isIntersecting","threshold","observe","disconnect","onClick","event","preventDefault","onMouseEnter","ele","notAvailableInServer","name","renderError","message","ErrorBoundary","constructor","getDerivedStateFromError","error","render","String","NotFound","has404","reset","resetError","Redirect","hostname","CustomErrorHandler","bind","setState","info","status","getRouteSlotId","decodeURIComponent","handleScroll","element","document","getElementById","scrollTo","left","top","getBoundingClientRect","scrollY","behavior","InnerRouter","routerData","initialRoute","locationListeners","staticPathSet","refetch","setRoute","prev","skipRefetch","has","rscPath","__WAKU_ROUTER_PREFETCH__","callback","addEventListener","removeEventListener","search","add","delete","routeElement","id","rootElement","unstable_handleError","Provider","value","DEFAULT_ROUTER_DATA","Router","unstable_enhanceFetch","unstable_enhanceCreateData","initialRscPath","Set","cachedIdSet","enhanceFetch","fetchFn","input","init","skipStr","JSON","stringify","Array","from","headers","isArray","enhanceCreateData","createData","responsePromise","data","Promise","resolve","then","routeData","isStatic","rest","listener","Object","keys","catch","initialRscParams","INTERNAL_ServerRouter"],"mappings":"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"}
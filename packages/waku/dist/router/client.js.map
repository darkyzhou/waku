{"version":3,"sources":["../../src/router/client.ts"],"sourcesContent":["'use client';\n\nimport {\n  createContext,\n  createElement,\n  useCallback,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n  useTransition,\n  Fragment,\n  Component,\n} from 'react';\nimport type {\n  ComponentProps,\n  FunctionComponent,\n  ReactNode,\n  AnchorHTMLAttributes,\n  ReactElement,\n  MouseEvent,\n} from 'react';\n\nimport {\n  prefetchRsc,\n  Root,\n  Slot,\n  useRefetch,\n  ThrowError_UNSTABLE as ThrowError,\n  useResetError_UNSTABLE as useResetError,\n} from '../minimal/client.js';\nimport {\n  encodeRoutePath,\n  ROUTE_ID,\n  IS_STATIC_ID,\n  HAS404_ID,\n  SKIP_HEADER,\n} from './common.js';\nimport type { RouteProps } from './common.js';\nimport type { RouteConfig } from './base-types.js';\nimport { getErrorInfo } from '../lib/utils/custom-errors.js';\n\ntype AllowPathDecorators<Path extends string> = Path extends unknown\n  ? Path | `${Path}?${string}` | `${Path}#${string}`\n  : never;\n\ntype InferredPaths = RouteConfig extends {\n  paths: infer UserPaths extends string;\n}\n  ? AllowPathDecorators<UserPaths>\n  : string;\n\ndeclare global {\n  interface ImportMeta {\n    readonly env: Record<string, string>;\n  }\n}\n\nconst normalizeRoutePath = (path: string) => {\n  for (const suffix of ['/', '/index.html']) {\n    if (path.endsWith(suffix)) {\n      return path.slice(0, -suffix.length) || '/';\n    }\n  }\n  return path;\n};\n\nconst parseRoute = (url: URL): RouteProps => {\n  const { pathname, searchParams, hash } = url;\n  return {\n    path: normalizeRoutePath(pathname),\n    query: searchParams.toString(),\n    hash,\n  };\n};\n\nconst parseRouteFromLocation = (): RouteProps => {\n  const httpStatusMeta = document.querySelector('meta[name=\"httpstatus\"]');\n  if (\n    httpStatusMeta &&\n    'content' in httpStatusMeta &&\n    httpStatusMeta.content === '404'\n  ) {\n    return { path: '/404', query: '', hash: '' };\n  }\n  return parseRoute(new URL(window.location.href));\n};\n\nconst isAltClick = (event: MouseEvent<HTMLAnchorElement>) =>\n  event.button !== 0 ||\n  !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n\nlet savedRscParams: [query: string, rscParams: URLSearchParams] | undefined;\n\nconst createRscParams = (query: string): URLSearchParams => {\n  if (savedRscParams && savedRscParams[0] === query) {\n    return savedRscParams[1];\n  }\n  const rscParams = new URLSearchParams({ query });\n  savedRscParams = [query, rscParams];\n  return rscParams;\n};\n\ntype ChangeRoute = (\n  route: RouteProps,\n  options: {\n    shouldScroll: boolean;\n    skipRefetch?: boolean;\n  },\n) => void;\n\ntype PrefetchRoute = (route: RouteProps) => void;\n\nconst RouterContext = createContext<{\n  route: RouteProps;\n  changeRoute: ChangeRoute;\n  prefetchRoute: PrefetchRoute;\n} | null>(null);\n\nexport function useRouter() {\n  const router = useContext(RouterContext);\n  if (!router) {\n    throw new Error('Missing Router');\n  }\n  const { route, changeRoute, prefetchRoute } = router;\n  const push = useCallback(\n    (\n      to: InferredPaths,\n      options?: {\n        /**\n         * indicates if the link should scroll or not on navigation\n         * - `true`: always scroll\n         * - `false`: never scroll\n         * - `undefined`: scroll on path change (not on searchParams change)\n         */\n        scroll?: boolean;\n      },\n    ) => {\n      const url = new URL(to, window.location.href);\n      const newPath = url.pathname !== window.location.pathname;\n      window.history.pushState(\n        {\n          ...window.history.state,\n          waku_new_path: newPath,\n        },\n        '',\n        url,\n      );\n      changeRoute(parseRoute(url), {\n        shouldScroll: options?.scroll ?? newPath,\n      });\n    },\n    [changeRoute],\n  );\n  const replace = useCallback(\n    (\n      to: InferredPaths,\n      options?: {\n        /**\n         * indicates if the link should scroll or not on navigation\n         * - `true`: always scroll\n         * - `false`: never scroll\n         * - `undefined`: scroll on path change (not on searchParams change)\n         */\n        scroll?: boolean;\n      },\n    ) => {\n      const url = new URL(to, window.location.href);\n      const newPath = url.pathname !== window.location.pathname;\n      window.history.replaceState(window.history.state, '', url);\n      changeRoute(parseRoute(url), {\n        shouldScroll: options?.scroll ?? newPath,\n      });\n    },\n    [changeRoute],\n  );\n  const reload = useCallback(() => {\n    const url = new URL(window.location.href);\n    changeRoute(parseRoute(url), { shouldScroll: true });\n  }, [changeRoute]);\n  const back = useCallback(() => {\n    // FIXME is this correct?\n    window.history.back();\n  }, []);\n  const forward = useCallback(() => {\n    // FIXME is this correct?\n    window.history.forward();\n  }, []);\n  const prefetch = useCallback(\n    (to: string) => {\n      const url = new URL(to, window.location.href);\n      prefetchRoute(parseRoute(url));\n    },\n    [prefetchRoute],\n  );\n  return {\n    ...route,\n    push,\n    replace,\n    reload,\n    back,\n    forward,\n    prefetch,\n  };\n}\n\nexport type LinkProps = {\n  to: InferredPaths;\n  children: ReactNode;\n  /**\n   * indicates if the link should scroll or not on navigation\n   * - `true`: always scroll\n   * - `false`: never scroll\n   * - `undefined`: scroll on path change (not on searchParams change)\n   */\n  scroll?: boolean;\n  unstable_pending?: ReactNode;\n  unstable_notPending?: ReactNode;\n  unstable_prefetchOnEnter?: boolean;\n  unstable_prefetchOnView?: boolean;\n  unstable_startTransition?: ((fn: () => void) => void) | undefined;\n} & Omit<AnchorHTMLAttributes<HTMLAnchorElement>, 'href'>;\n\nexport function Link({\n  to,\n  children,\n  scroll,\n  unstable_pending,\n  unstable_notPending,\n  unstable_prefetchOnEnter,\n  unstable_prefetchOnView,\n  unstable_startTransition,\n  ...props\n}: LinkProps): ReactElement {\n  const router = useContext(RouterContext);\n  const changeRoute = router\n    ? router.changeRoute\n    : () => {\n        throw new Error('Missing Router');\n      };\n  const prefetchRoute = router\n    ? router.prefetchRoute\n    : () => {\n        throw new Error('Missing Router');\n      };\n  const [isPending, startTransition] = useTransition();\n  const startTransitionFn =\n    unstable_startTransition ||\n    ((unstable_pending || unstable_notPending) && startTransition) ||\n    ((fn: () => void) => fn());\n  const ref = useRef<HTMLAnchorElement>(undefined);\n\n  useEffect(() => {\n    if (unstable_prefetchOnView && ref.current) {\n      const observer = new IntersectionObserver(\n        (entries) => {\n          entries.forEach((entry) => {\n            if (entry.isIntersecting) {\n              const url = new URL(to, window.location.href);\n              if (router && url.href !== window.location.href) {\n                const route = parseRoute(url);\n                router.prefetchRoute(route);\n              }\n            }\n          });\n        },\n        { threshold: 0.1 },\n      );\n\n      observer.observe(ref.current);\n\n      return () => {\n        observer.disconnect();\n      };\n    }\n  }, [unstable_prefetchOnView, router, to]);\n  const internalOnClick = () => {\n    const url = new URL(to, window.location.href);\n    if (url.href !== window.location.href) {\n      const route = parseRoute(url);\n      prefetchRoute(route);\n      startTransitionFn(() => {\n        const newPath = url.pathname !== window.location.pathname;\n        window.history.pushState(\n          {\n            ...window.history.state,\n            waku_new_path: newPath,\n          },\n          '',\n          url,\n        );\n        changeRoute(route, { shouldScroll: scroll ?? newPath });\n      });\n    }\n  };\n  const onClick = (event: MouseEvent<HTMLAnchorElement>) => {\n    if (props.onClick) {\n      props.onClick(event);\n    }\n    if (!event.defaultPrevented && !isAltClick(event)) {\n      event.preventDefault();\n      internalOnClick();\n    }\n  };\n  const onMouseEnter = unstable_prefetchOnEnter\n    ? (event: MouseEvent<HTMLAnchorElement>) => {\n        const url = new URL(to, window.location.href);\n        if (url.href !== window.location.href) {\n          const route = parseRoute(url);\n          prefetchRoute(route);\n        }\n        props.onMouseEnter?.(event);\n      }\n    : props.onMouseEnter;\n  const ele = createElement(\n    'a',\n    { ...props, href: to, onClick, onMouseEnter, ref },\n    children,\n  );\n  if (isPending && unstable_pending !== undefined) {\n    return createElement(Fragment, null, ele, unstable_pending);\n  }\n  if (!isPending && unstable_notPending !== undefined) {\n    return createElement(Fragment, null, ele, unstable_notPending);\n  }\n  return ele;\n}\n\nconst notAvailableInServer = (name: string) => () => {\n  throw new Error(`${name} is not in the server`);\n};\n\nfunction renderError(message: string) {\n  return createElement(\n    'html',\n    null,\n    createElement('body', null, createElement('h1', null, message)),\n  );\n}\n\nexport class ErrorBoundary extends Component<\n  { children: ReactNode },\n  { error?: unknown }\n> {\n  constructor(props: { children: ReactNode }) {\n    super(props);\n    this.state = {};\n  }\n  static getDerivedStateFromError(error: unknown) {\n    return { error };\n  }\n  render() {\n    if ('error' in this.state) {\n      if (this.state.error instanceof Error) {\n        return renderError(this.state.error.message);\n      }\n      return renderError(String(this.state.error));\n    }\n    return this.props.children;\n  }\n}\n\nconst NotFound = ({\n  has404,\n  reset,\n}: {\n  has404: boolean;\n  reset: () => void;\n}) => {\n  const resetError = useResetError();\n  const router = useContext(RouterContext);\n  if (!router) {\n    throw new Error('Missing Router');\n  }\n  const { changeRoute } = router;\n  useEffect(() => {\n    if (has404) {\n      const url = new URL('/404', window.location.href);\n      changeRoute(parseRoute(url), { shouldScroll: true });\n      resetError?.();\n      reset();\n    }\n  }, [has404, resetError, reset, changeRoute]);\n  return has404 ? null : createElement('h1', null, 'Not Found');\n};\n\nconst Redirect = ({ to, reset }: { to: string; reset: () => void }) => {\n  const resetError = useResetError();\n  const router = useContext(RouterContext);\n  if (!router) {\n    throw new Error('Missing Router');\n  }\n  const { changeRoute } = router;\n  useEffect(() => {\n    const url = new URL(to, window.location.href);\n    // FIXME this condition seems too naive\n    if (url.hostname !== window.location.hostname) {\n      window.location.replace(to);\n      return;\n    }\n    const newPath = url.pathname !== window.location.pathname;\n    window.history.pushState(\n      {\n        ...window.history.state,\n        waku_new_path: newPath,\n      },\n      '',\n      url,\n    );\n    changeRoute(parseRoute(url), { shouldScroll: newPath });\n    resetError?.();\n    reset();\n  }, [to, resetError, reset, changeRoute]);\n  return null;\n};\n\nclass CustomErrorHandler extends Component<\n  { has404: boolean; children?: ReactNode },\n  { error: unknown | null }\n> {\n  constructor(props: { has404: boolean; children?: ReactNode }) {\n    super(props);\n    this.state = { error: null };\n    this.reset = this.reset.bind(this);\n  }\n  static getDerivedStateFromError(error: unknown) {\n    return { error };\n  }\n  reset() {\n    this.setState({ error: null });\n  }\n  render() {\n    const { error } = this.state;\n    if (error !== null) {\n      const info = getErrorInfo(error);\n      if (info?.status === 404) {\n        return createElement(NotFound, {\n          has404: this.props.has404,\n          reset: this.reset,\n        });\n      }\n      if (info?.location) {\n        return createElement(Redirect, {\n          to: info.location,\n          reset: this.reset,\n        });\n      }\n      throw error;\n    }\n    return this.props.children;\n  }\n}\n\nconst getRouteSlotId = (path: string) => 'route:' + decodeURIComponent(path);\n\nconst handleScroll = () => {\n  const { hash } = window.location;\n  const { state } = window.history;\n  const element = hash && document.getElementById(hash.slice(1));\n  window.scrollTo({\n    left: 0,\n    top: element ? element.getBoundingClientRect().top + window.scrollY : 0,\n    behavior: state?.waku_new_path ? 'instant' : 'auto',\n  });\n};\n\nconst InnerRouter = ({\n  routerData,\n  initialRoute,\n}: {\n  routerData: Required<RouterData>;\n  initialRoute: RouteProps;\n}) => {\n  const [locationListeners, staticPathSet, , has404] = routerData;\n  const refetch = useRefetch();\n  const [route, setRoute] = useState(() => ({\n    // This is the first initialization of the route, and it has\n    // to ignore the hash, because on server side there is none.\n    // Otherwise there will be a hydration error.\n    // The client side route, including the hash, will be updated in the effect below.\n    ...initialRoute,\n    hash: '',\n  }));\n  // Update the route post-load to include the current hash.\n  useEffect(() => {\n    setRoute((prev) => {\n      if (\n        prev.path === initialRoute.path &&\n        prev.query === initialRoute.query &&\n        prev.hash === initialRoute.hash\n      ) {\n        return prev;\n      }\n      return initialRoute;\n    });\n  }, [initialRoute]);\n\n  const changeRoute: ChangeRoute = useCallback(\n    (route, options) => {\n      const { skipRefetch } = options || {};\n      if (!staticPathSet.has(route.path) && !skipRefetch) {\n        const rscPath = encodeRoutePath(route.path);\n        const rscParams = createRscParams(route.query);\n        refetch(rscPath, rscParams);\n      }\n      if (options.shouldScroll) {\n        handleScroll();\n      }\n      setRoute(route);\n    },\n    [refetch, staticPathSet],\n  );\n\n  const prefetchRoute: PrefetchRoute = useCallback(\n    (route) => {\n      if (staticPathSet.has(route.path)) {\n        return;\n      }\n      const rscPath = encodeRoutePath(route.path);\n      const rscParams = createRscParams(route.query);\n      prefetchRsc(rscPath, rscParams);\n      (globalThis as any).__WAKU_ROUTER_PREFETCH__?.(route.path);\n    },\n    [staticPathSet],\n  );\n\n  useEffect(() => {\n    const callback = () => {\n      const route = parseRoute(new URL(window.location.href));\n      changeRoute(route, { shouldScroll: true });\n    };\n    window.addEventListener('popstate', callback);\n    return () => {\n      window.removeEventListener('popstate', callback);\n    };\n  }, [changeRoute]);\n\n  useEffect(() => {\n    const callback = (path: string, query: string) => {\n      const url = new URL(window.location.href);\n      url.pathname = path;\n      url.search = query;\n      url.hash = '';\n      if (path !== '/404') {\n        window.history.pushState(\n          {\n            ...window.history.state,\n            waku_new_path: url.pathname !== window.location.pathname,\n          },\n          '',\n          url,\n        );\n      }\n      changeRoute(parseRoute(url), { skipRefetch: true, shouldScroll: false });\n    };\n    locationListeners.add(callback);\n    return () => {\n      locationListeners.delete(callback);\n    };\n  }, [changeRoute, locationListeners]);\n\n  const routeElement = createElement(Slot, { id: getRouteSlotId(route.path) });\n  const rootElement = createElement(\n    Slot,\n    {\n      id: 'root',\n      unstable_handleError: createElement(\n        CustomErrorHandler,\n        { has404 },\n        createElement(ThrowError),\n      ),\n    },\n    createElement(CustomErrorHandler, { has404 }, routeElement),\n  );\n  return createElement(\n    RouterContext.Provider,\n    { value: { route, changeRoute, prefetchRoute } },\n    rootElement,\n  );\n};\n\ntype Elements = Record<string, unknown>;\ntype EnhanceFetch = (fetchFn: typeof fetch) => typeof fetch;\ntype EnhanceCreateData = (\n  createData: (responsePromise: Promise<Response>) => Promise<Elements>,\n) => (responsePromise: Promise<Response>) => Promise<Elements>;\n\n// Note: The router data must be a stable mutable object (array).\ntype RouterData = [\n  locationListeners?: Set<(path: string, query: string) => void>,\n  staticPathSet?: Set<string>,\n  cachedIdSet?: Set<string>,\n  has404?: boolean,\n];\n\nconst DEFAULT_ROUTER_DATA: RouterData = [];\n\nexport function Router({\n  routerData = DEFAULT_ROUTER_DATA,\n  initialRoute = parseRouteFromLocation(),\n  unstable_enhanceFetch,\n  unstable_enhanceCreateData,\n}: {\n  routerData?: RouterData;\n  initialRoute?: RouteProps;\n  unstable_enhanceFetch?: EnhanceFetch;\n  unstable_enhanceCreateData?: EnhanceCreateData;\n}) {\n  const initialRscPath = encodeRoutePath(initialRoute.path);\n  const locationListeners = (routerData[0] ||= new Set());\n  const staticPathSet = (routerData[1] ||= new Set());\n  const cachedIdSet = (routerData[2] ||= new Set());\n  const enhanceFetch =\n    (fetchFn: typeof fetch) =>\n    (input: RequestInfo | URL, init: RequestInit = {}) => {\n      const skipStr = JSON.stringify(Array.from(cachedIdSet));\n      const headers = (init.headers ||= {});\n      if (Array.isArray(headers)) {\n        headers.push([SKIP_HEADER, skipStr]);\n      } else {\n        (headers as Record<string, string>)[SKIP_HEADER] = skipStr;\n      }\n      return fetchFn(input, init);\n    };\n  const enhanceCreateData =\n    (\n      createData: (\n        responsePromise: Promise<Response>,\n      ) => Promise<Record<string, unknown>>,\n    ) =>\n    async (responsePromise: Promise<Response>) => {\n      const data = createData(responsePromise);\n      Promise.resolve(data)\n        .then((data) => {\n          if (data && typeof data === 'object') {\n            const {\n              [ROUTE_ID]: routeData,\n              [IS_STATIC_ID]: isStatic,\n              [HAS404_ID]: has404,\n              ...rest\n            } = data;\n            if (routeData) {\n              const [path, query] = routeData as [string, string];\n              // FIXME this check here seems ad-hoc (less readable code)\n              if (\n                window.location.pathname !== path ||\n                (!isStatic &&\n                  window.location.search.replace(/^\\?/, '') !== query)\n              ) {\n                locationListeners.forEach((listener) => listener(path, query));\n              }\n              if (isStatic) {\n                staticPathSet.add(path);\n              }\n            }\n            if (has404) {\n              routerData[3] = true;\n            }\n            Object.keys(rest).forEach((id) => {\n              cachedIdSet.add(id);\n            });\n          }\n        })\n        .catch(() => {});\n      return data;\n    };\n  const initialRscParams = createRscParams(initialRoute.query);\n  return createElement(\n    Root as FunctionComponent<Omit<ComponentProps<typeof Root>, 'children'>>,\n    {\n      initialRscPath,\n      initialRscParams,\n      unstable_enhanceFetch: unstable_enhanceFetch\n        ? (fn) => unstable_enhanceFetch(enhanceFetch(fn))\n        : enhanceFetch,\n      unstable_enhanceCreateData: unstable_enhanceCreateData\n        ? (fn) => unstable_enhanceCreateData(enhanceCreateData(fn))\n        : enhanceCreateData,\n    },\n    createElement(InnerRouter, {\n      routerData: routerData as Required<RouterData>,\n      initialRoute,\n    }),\n  );\n}\n\n/**\n * ServerRouter for SSR\n * This is not a public API.\n */\nexport function INTERNAL_ServerRouter({\n  route,\n  httpstatus,\n}: {\n  route: RouteProps;\n  httpstatus: number;\n}) {\n  const routeElement = createElement(Slot, { id: getRouteSlotId(route.path) });\n  const rootElement = createElement(\n    Slot,\n    { id: 'root', unstable_handleError: null },\n    createElement('meta', { name: 'httpstatus', content: `${httpstatus}` }),\n    routeElement,\n  );\n  return createElement(\n    Fragment,\n    null,\n    createElement(\n      RouterContext.Provider,\n      {\n        value: {\n          route,\n          changeRoute: notAvailableInServer('changeRoute'),\n          prefetchRoute: notAvailableInServer('prefetchRoute'),\n        },\n      },\n      rootElement,\n    ),\n  );\n}\n"],"names":["createContext","createElement","useCallback","useContext","useEffect","useRef","useState","useTransition","Fragment","Component","prefetchRsc","Root","Slot","useRefetch","ThrowError_UNSTABLE","ThrowError","useResetError_UNSTABLE","useResetError","encodeRoutePath","ROUTE_ID","IS_STATIC_ID","HAS404_ID","SKIP_HEADER","getErrorInfo","normalizeRoutePath","path","suffix","endsWith","slice","length","parseRoute","url","pathname","searchParams","hash","query","toString","parseRouteFromLocation","httpStatusMeta","document","querySelector","content","URL","window","location","href","isAltClick","event","button","metaKey","altKey","ctrlKey","shiftKey","savedRscParams","createRscParams","rscParams","URLSearchParams","RouterContext","useRouter","router","Error","route","changeRoute","prefetchRoute","push","to","options","newPath","history","pushState","state","waku_new_path","shouldScroll","scroll","replace","replaceState","reload","back","forward","prefetch","Link","children","unstable_pending","unstable_notPending","unstable_prefetchOnEnter","unstable_prefetchOnView","unstable_startTransition","props","isPending","startTransition","startTransitionFn","fn","ref","undefined","current","observer","IntersectionObserver","entries","forEach","entry","isIntersecting","threshold","observe","disconnect","internalOnClick","onClick","defaultPrevented","preventDefault","onMouseEnter","ele","notAvailableInServer","name","renderError","message","ErrorBoundary","constructor","getDerivedStateFromError","error","render","String","NotFound","has404","reset","resetError","Redirect","hostname","CustomErrorHandler","bind","setState","info","status","getRouteSlotId","decodeURIComponent","handleScroll","element","getElementById","scrollTo","left","top","getBoundingClientRect","scrollY","behavior","InnerRouter","routerData","initialRoute","locationListeners","staticPathSet","refetch","setRoute","prev","skipRefetch","has","rscPath","globalThis","__WAKU_ROUTER_PREFETCH__","callback","addEventListener","removeEventListener","search","add","delete","routeElement","id","rootElement","unstable_handleError","Provider","value","DEFAULT_ROUTER_DATA","Router","unstable_enhanceFetch","unstable_enhanceCreateData","initialRscPath","Set","cachedIdSet","enhanceFetch","fetchFn","input","init","skipStr","JSON","stringify","Array","from","headers","isArray","enhanceCreateData","createData","responsePromise","data","Promise","resolve","then","routeData","isStatic","rest","listener","Object","keys","catch","initialRscParams","INTERNAL_ServerRouter","httpstatus"],"mappings":"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"}
{"version":3,"sources":["../../src/router/define-router.ts"],"sourcesContent":["import { createElement } from 'react';\nimport type { ReactNode } from 'react';\n\nimport {\n  unstable_getPlatformData,\n  unstable_setPlatformData,\n  unstable_createAsyncIterable as createAsyncIterable,\n} from '../server.js';\nimport { unstable_defineEntries as defineEntries } from '../minimal/server.js';\nimport {\n  encodeRoutePath,\n  decodeRoutePath,\n  ROUTE_ID,\n  IS_STATIC_ID,\n  HAS404_ID,\n  SKIP_HEADER,\n} from './common.js';\nimport { getPathMapping, path2regexp } from '../lib/utils/path.js';\nimport type { PathSpec } from '../lib/utils/path.js';\nimport { INTERNAL_ServerRouter } from './client.js';\nimport { getContext } from '../middleware/context.js';\nimport { stringToStream } from '../lib/utils/stream.js';\nimport { createCustomError, getErrorInfo } from '../lib/utils/custom-errors.js';\n\nconst isStringArray = (x: unknown): x is string[] =>\n  Array.isArray(x) && x.every((y) => typeof y === 'string');\n\nconst parseRscParams = (\n  rscParams: unknown,\n): {\n  query: string;\n} => {\n  if (rscParams instanceof URLSearchParams) {\n    return { query: rscParams.get('query') || '' };\n  }\n  if (\n    typeof (rscParams as { query?: undefined } | undefined)?.query === 'string'\n  ) {\n    return { query: (rscParams as { query: string }).query };\n  }\n  return { query: '' };\n};\n\nconst RSC_PARAMS_SYMBOL = Symbol('RSC_PARAMS');\n\nconst setRscParams = (rscParams: unknown) => {\n  try {\n    const context = getContext();\n    (context as unknown as Record<typeof RSC_PARAMS_SYMBOL, unknown>)[\n      RSC_PARAMS_SYMBOL\n    ] = rscParams;\n  } catch {\n    // ignore\n  }\n};\n\nexport function unstable_getRscParams(): unknown {\n  try {\n    const context = getContext();\n    return (context as unknown as Record<typeof RSC_PARAMS_SYMBOL, Rerender>)[\n      RSC_PARAMS_SYMBOL\n    ];\n  } catch {\n    return undefined;\n  }\n}\n\nconst RERENDER_SYMBOL = Symbol('RERENDER');\ntype Rerender = (rscPath: string, rscParams?: unknown) => void;\n\nconst setRerender = (rerender: Rerender) => {\n  try {\n    const context = getContext();\n    (context as unknown as Record<typeof RERENDER_SYMBOL, Rerender>)[\n      RERENDER_SYMBOL\n    ] = rerender;\n  } catch {\n    // ignore\n  }\n};\n\nconst getRerender = (): Rerender => {\n  const context = getContext();\n  return (context as unknown as Record<typeof RERENDER_SYMBOL, Rerender>)[\n    RERENDER_SYMBOL\n  ];\n};\n\nconst pathSpec2pathname = (pathSpec: PathSpec) => {\n  if (pathSpec.some(({ type }) => type !== 'literal')) {\n    return undefined;\n  }\n  return '/' + pathSpec.map(({ name }) => name!).join('/');\n};\n\nexport function unstable_rerenderRoute(pathname: string, query?: string) {\n  const rscPath = encodeRoutePath(pathname);\n  getRerender()(rscPath, query && new URLSearchParams({ query }));\n}\n\nexport function unstable_notFound(): never {\n  throw createCustomError('Not Found', { status: 404 });\n}\n\nexport function unstable_redirect(\n  location: string,\n  status: 307 | 308 = 307,\n): never {\n  throw createCustomError('Redirect', { status, location });\n}\n\ntype SlotId = string;\n\nconst ROUTE_SLOT_ID_PREFIX = 'route:';\n\nexport function unstable_defineRouter(fns: {\n  getRouteConfig: () => Promise<\n    Iterable<{\n      path: PathSpec;\n      pathPattern?: PathSpec;\n      rootElement: { isStatic?: boolean };\n      routeElement: { isStatic?: boolean };\n      elements: Record<SlotId, { isStatic?: boolean }>;\n      noSsr?: boolean;\n    }>\n  >;\n  handleRoute: (\n    path: string,\n    options: {\n      query?: string;\n    },\n  ) => Promise<{\n    rootElement: ReactNode;\n    routeElement: ReactNode;\n    elements: Record<SlotId, unknown>;\n  }>;\n  getApiConfig?: () => Promise<\n    Iterable<{\n      path: PathSpec;\n      isStatic?: boolean;\n    }>\n  >;\n  handleApi?: (\n    path: string,\n    options: {\n      url: URL;\n      body: ReadableStream | null;\n      headers: Readonly<Record<string, string>>;\n      method: string;\n    },\n  ) => Promise<{\n    body?: ReadableStream;\n    headers?: Record<string, string | string[]>;\n    status?: number;\n  }>;\n}) {\n  type MyPathConfig = {\n    pathSpec: PathSpec;\n    pathname: string | undefined;\n    pattern: string;\n    specs: {\n      rootElementIsStatic?: true;\n      routeElementIsStatic?: true;\n      staticElementIds?: SlotId[];\n      isStatic?: true;\n      noSsr?: true;\n      is404?: true;\n      isApi?: true;\n    };\n  }[];\n  let cachedPathConfig: MyPathConfig | undefined;\n  const getMyPathConfig = async (): Promise<MyPathConfig> => {\n    const pathConfig = await unstable_getPlatformData(\n      'defineRouterPathConfigs',\n    );\n    if (pathConfig) {\n      return pathConfig as MyPathConfig;\n    }\n    if (!cachedPathConfig) {\n      cachedPathConfig = [\n        ...Array.from(await fns.getRouteConfig()).map((item) => {\n          const is404 =\n            item.path.length === 1 &&\n            item.path[0]!.type === 'literal' &&\n            item.path[0]!.name === '404';\n          const isStatic =\n            !!item.rootElement.isStatic &&\n            !!item.routeElement.isStatic &&\n            Object.values(item.elements).every((x) => x.isStatic);\n          return {\n            pathSpec: item.path,\n            pathname: pathSpec2pathname(item.path),\n            pattern: path2regexp(item.pathPattern || item.path),\n            specs: {\n              ...(item.rootElement.isStatic\n                ? { rootElementIsStatic: true as const }\n                : {}),\n              ...(item.routeElement.isStatic\n                ? { routeElementIsStatic: true as const }\n                : {}),\n              staticElementIds: Object.entries(item.elements).flatMap(\n                ([id, { isStatic }]) => (isStatic ? [id] : []),\n              ),\n              ...(isStatic ? { isStatic: true as const } : {}),\n              ...(is404 ? { is404: true as const } : {}),\n              ...(item.noSsr ? { noSsr: true as const } : {}),\n            },\n          };\n        }),\n        ...Array.from((await fns.getApiConfig?.()) || []).map((item) => {\n          return {\n            pathSpec: item.path,\n            pathname: pathSpec2pathname(item.path),\n            pattern: path2regexp(item.path),\n            specs: {\n              ...(item.isStatic ? { isStatic: true as const } : {}),\n              isApi: true as const,\n            },\n          };\n        }),\n      ];\n    }\n    return cachedPathConfig;\n  };\n  const getPathConfigItem = async (pathname: string) => {\n    const pathConfig = await getMyPathConfig();\n    const found = pathConfig.find(({ pathSpec }) =>\n      getPathMapping(pathSpec, pathname),\n    );\n    return found;\n  };\n  const has404 = async () => {\n    const pathConfig = await getMyPathConfig();\n    return pathConfig.some(({ specs: { is404 } }) => is404);\n  };\n  const getEntries = async (\n    rscPath: string,\n    rscParams: unknown,\n    headers: Readonly<Record<string, string>>,\n  ) => {\n    setRscParams(rscParams);\n    const pathname = decodeRoutePath(rscPath);\n    const pathConfigItem = await getPathConfigItem(pathname);\n    if (!pathConfigItem) {\n      return null;\n    }\n    let skipParam: unknown;\n    try {\n      skipParam = JSON.parse(headers[SKIP_HEADER.toLowerCase()] || '');\n    } catch {\n      // ignore\n    }\n    const skipIdSet = new Set(isStringArray(skipParam) ? skipParam : []);\n    const { query } = parseRscParams(rscParams);\n    const { rootElement, routeElement, elements } = await fns.handleRoute(\n      pathname,\n      pathConfigItem.specs.isStatic ? {} : { query },\n    );\n    if (\n      Object.keys(elements).some((id) => id.startsWith(ROUTE_SLOT_ID_PREFIX))\n    ) {\n      throw new Error('Element ID cannot start with \"route:\"');\n    }\n    const entries = {\n      ...elements,\n    };\n    for (const id of pathConfigItem.specs.staticElementIds || []) {\n      if (skipIdSet.has(id)) {\n        delete entries[id];\n      }\n    }\n    if (!pathConfigItem.specs.rootElementIsStatic || !skipIdSet.has('root')) {\n      entries.root = rootElement;\n    }\n    const decodedPathname = decodeURIComponent(pathname);\n    const routeId = ROUTE_SLOT_ID_PREFIX + decodedPathname;\n    if (!pathConfigItem.specs.routeElementIsStatic || !skipIdSet.has(routeId)) {\n      entries[routeId] = routeElement;\n    }\n    entries[ROUTE_ID] = [decodedPathname, query];\n    entries[IS_STATIC_ID] = !!pathConfigItem.specs.isStatic;\n    if (await has404()) {\n      entries[HAS404_ID] = true;\n    }\n    return entries;\n  };\n\n  type HandleRequest = Parameters<typeof defineEntries>[0]['handleRequest'];\n  type HandleBuild = Parameters<typeof defineEntries>[0]['handleBuild'];\n  type BuildConfig =\n    NonNullable<ReturnType<HandleBuild>> extends AsyncIterable<infer T>\n      ? T\n      : never;\n\n  const handleRequest: HandleRequest = async (\n    input,\n    { renderRsc, renderHtml },\n  ) => {\n    if (input.type === 'component') {\n      const entries = await getEntries(\n        input.rscPath,\n        input.rscParams,\n        input.req.headers,\n      );\n      if (!entries) {\n        return null;\n      }\n      return renderRsc(entries);\n    }\n    if (input.type === 'function') {\n      let elementsPromise: Promise<Record<string, unknown>> = Promise.resolve(\n        {},\n      );\n      let rendered = false;\n      const rerender = async (rscPath: string, rscParams?: unknown) => {\n        if (rendered) {\n          throw new Error('already rendered');\n        }\n        elementsPromise = Promise.all([\n          elementsPromise,\n          getEntries(rscPath, rscParams, input.req.headers),\n        ]).then(([oldElements, newElements]) => {\n          if (newElements === null) {\n            console.warn('getEntries returned null');\n          }\n          return {\n            ...oldElements,\n            ...newElements,\n          };\n        });\n      };\n      setRerender(rerender);\n      const value = await input.fn(...input.args);\n      rendered = true;\n      return renderRsc({ ...(await elementsPromise), _value: value });\n    }\n    const pathConfigItem = await getPathConfigItem(input.pathname);\n    if (pathConfigItem?.specs?.isApi && fns.handleApi) {\n      return fns.handleApi(input.pathname, {\n        url: input.req.url,\n        body: input.req.body,\n        headers: input.req.headers,\n        method: input.req.method,\n      });\n    }\n    if (input.type === 'action' || input.type === 'custom') {\n      const renderIt = async (\n        pathname: string,\n        query: string,\n        httpstatus = 200,\n      ) => {\n        const rscPath = encodeRoutePath(pathname);\n        const rscParams = new URLSearchParams({ query });\n        const entries = await getEntries(rscPath, rscParams, input.req.headers);\n        if (!entries) {\n          return null;\n        }\n        const html = createElement(INTERNAL_ServerRouter, {\n          route: { path: pathname, query, hash: '' },\n          httpstatus,\n        });\n        const actionResult =\n          input.type === 'action' ? await input.fn() : undefined;\n        return renderHtml(entries, html, { rscPath, actionResult });\n      };\n      const query = input.req.url.searchParams.toString();\n      if (pathConfigItem?.specs?.noSsr) {\n        return null;\n      }\n      try {\n        if (pathConfigItem) {\n          return await renderIt(input.pathname, query);\n        }\n      } catch (e) {\n        const info = getErrorInfo(e);\n        if (info?.status !== 404) {\n          throw e;\n        }\n      }\n      if (await has404()) {\n        return { ...(await renderIt('/404', '', 404)), status: 404 };\n      } else {\n        return null;\n      }\n    }\n  };\n\n  type Tasks = Array<() => Promise<BuildConfig>>;\n  const handleBuild: HandleBuild = ({\n    renderRsc,\n    renderHtml,\n    rscPath2pathname,\n    unstable_generatePrefetchCode,\n    unstable_collectClientModules,\n  }) =>\n    createAsyncIterable(async (): Promise<Tasks> => {\n      const tasks: Tasks = [];\n      const pathConfig = await getMyPathConfig();\n\n      for (const { pathname, specs } of pathConfig) {\n        const { handleApi } = fns;\n        if (pathname && specs.isStatic && specs.isApi && handleApi) {\n          tasks.push(async () => ({\n            type: 'file',\n            pathname,\n            body: handleApi(pathname, {\n              url: new URL(pathname, 'http://localhost:3000'),\n              body: null,\n              headers: {},\n              method: 'GET',\n            }).then(({ body }) => body || stringToStream('')),\n          }));\n        }\n      }\n\n      const path2moduleIds: Record<string, string[]> = {};\n      const moduleIdsForPrefetch = new WeakMap<PathSpec, Set<string>>();\n      // FIXME this approach keeps all entries in memory during the loop\n      const entriesCache = new Map<string, Record<string, unknown>>();\n      await Promise.all(\n        pathConfig.map(async ({ pathSpec, pathname, pattern, specs }) => {\n          if (specs.isApi) {\n            return;\n          }\n          const moduleIds = new Set<string>();\n          moduleIdsForPrefetch.set(pathSpec, moduleIds);\n          if (!pathname) {\n            return;\n          }\n          const rscPath = encodeRoutePath(pathname);\n          const entries = await getEntries(rscPath, undefined, {});\n          if (entries) {\n            entriesCache.set(pathname, entries);\n            path2moduleIds[pattern] =\n              await unstable_collectClientModules(entries);\n            if (specs.isStatic) {\n              tasks.push(async () => ({\n                type: 'file',\n                pathname: rscPath2pathname(rscPath),\n                body: renderRsc(entries, {\n                  moduleIdCallback: (id) => moduleIds.add(id),\n                }),\n              }));\n            }\n          }\n        }),\n      );\n\n      const getRouterPrefetchCode = () => `\nglobalThis.__WAKU_ROUTER_PREFETCH__ = (path) => {\n  const path2ids = ${JSON.stringify(path2moduleIds)};\n  const pattern = Object.keys(path2ids).find((key) => new RegExp(key).test(path));\n  if (pattern && path2ids[pattern]) {\n    for (const id of path2ids[pattern] || []) {\n      import(id);\n    }\n  }\n};`;\n\n      for (const { pathSpec, pathname, specs } of pathConfig) {\n        if (specs.isApi) {\n          continue;\n        }\n        tasks.push(async () => {\n          const moduleIds = moduleIdsForPrefetch.get(pathSpec)!;\n          if (pathname) {\n            const rscPath = encodeRoutePath(pathname);\n            const code =\n              unstable_generatePrefetchCode([rscPath], moduleIds) +\n              getRouterPrefetchCode();\n            const entries = entriesCache.get(pathname);\n            if (specs.isStatic && entries) {\n              const html = createElement(INTERNAL_ServerRouter, {\n                route: { path: pathname, query: '', hash: '' },\n                httpstatus: specs.is404 ? 404 : 200,\n              });\n              return {\n                type: 'file',\n                pathname,\n                body: renderHtml(entries, html, {\n                  rscPath,\n                  htmlHead: `<script type=\"module\" async>${code}</script>`,\n                }).then(({ body }) => body),\n              };\n            }\n          }\n          const code =\n            unstable_generatePrefetchCode([], moduleIds) +\n            getRouterPrefetchCode();\n          return {\n            type: 'htmlHead',\n            pathSpec,\n            head: `<script type=\"module\" async>${code}</script>`,\n          };\n        });\n      }\n\n      await unstable_setPlatformData(\n        'defineRouterPathConfigs',\n        pathConfig,\n        true,\n      );\n      return tasks;\n    });\n\n  return defineEntries({ handleRequest, handleBuild });\n}\n"],"names":["createElement","unstable_getPlatformData","unstable_setPlatformData","unstable_createAsyncIterable","createAsyncIterable","unstable_defineEntries","defineEntries","encodeRoutePath","decodeRoutePath","ROUTE_ID","IS_STATIC_ID","HAS404_ID","SKIP_HEADER","getPathMapping","path2regexp","INTERNAL_ServerRouter","getContext","stringToStream","createCustomError","getErrorInfo","isStringArray","x","Array","isArray","every","y","parseRscParams","rscParams","URLSearchParams","query","get","RSC_PARAMS_SYMBOL","Symbol","setRscParams","context","unstable_getRscParams","undefined","RERENDER_SYMBOL","setRerender","rerender","getRerender","pathSpec2pathname","pathSpec","some","type","map","name","join","unstable_rerenderRoute","pathname","rscPath","unstable_notFound","status","unstable_redirect","location","ROUTE_SLOT_ID_PREFIX","unstable_defineRouter","fns","cachedPathConfig","getMyPathConfig","pathConfig","from","getRouteConfig","item","is404","path","length","isStatic","rootElement","routeElement","Object","values","elements","pattern","pathPattern","specs","rootElementIsStatic","routeElementIsStatic","staticElementIds","entries","flatMap","id","noSsr","getApiConfig","isApi","getPathConfigItem","found","find","has404","getEntries","headers","pathConfigItem","skipParam","JSON","parse","toLowerCase","skipIdSet","Set","handleRoute","keys","startsWith","Error","has","root","decodedPathname","decodeURIComponent","routeId","handleRequest","input","renderRsc","renderHtml","req","elementsPromise","Promise","resolve","rendered","all","then","oldElements","newElements","console","warn","value","fn","args","_value","handleApi","url","body","method","renderIt","httpstatus","html","route","hash","actionResult","searchParams","toString","e","info","handleBuild","rscPath2pathname","unstable_generatePrefetchCode","unstable_collectClientModules","tasks","push","URL","path2moduleIds","moduleIdsForPrefetch","WeakMap","entriesCache","Map","moduleIds","set","moduleIdCallback","add","getRouterPrefetchCode","stringify","code","htmlHead","head"],"mappings":"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"}
{"version":3,"sources":["../../src/router/define-router.ts"],"sourcesContent":["import { createElement } from 'react';\nimport type { ReactNode } from 'react';\n\nimport {\n  unstable_getPlatformData,\n  unstable_setPlatformData,\n  unstable_createAsyncIterable as createAsyncIterable,\n} from '../server.js';\nimport { unstable_defineEntries as defineEntries } from '../minimal/server.js';\nimport {\n  encodeRoutePath,\n  decodeRoutePath,\n  ROUTE_ID,\n  IS_STATIC_ID,\n  HAS404_ID,\n  SKIP_HEADER,\n} from './common.js';\nimport { getPathMapping, path2regexp } from '../lib/utils/path.js';\nimport type { PathSpec } from '../lib/utils/path.js';\nimport { INTERNAL_ServerRouter } from './client.js';\nimport { getContext } from '../middleware/context.js';\nimport { stringToStream } from '../lib/utils/stream.js';\nimport { createCustomError, getErrorInfo } from '../lib/utils/custom-errors.js';\n\nconst isStringArray = (x: unknown): x is string[] =>\n  Array.isArray(x) && x.every((y) => typeof y === 'string');\n\nconst parseRscParams = (\n  rscParams: unknown,\n): {\n  query: string;\n} => {\n  if (!(rscParams instanceof URLSearchParams)) {\n    return { query: '' };\n  }\n  const query = rscParams.get('query') || '';\n  return { query };\n};\n\nconst RERENDER_SYMBOL = Symbol('RERENDER');\ntype Rerender = (rscPath: string, rscParams?: unknown) => void;\n\nconst setRerender = (rerender: Rerender) => {\n  try {\n    const context = getContext();\n    (context as unknown as Record<typeof RERENDER_SYMBOL, Rerender>)[\n      RERENDER_SYMBOL\n    ] = rerender;\n  } catch {\n    // ignore\n  }\n};\n\nconst getRerender = (): Rerender => {\n  const context = getContext();\n  return (context as unknown as Record<typeof RERENDER_SYMBOL, Rerender>)[\n    RERENDER_SYMBOL\n  ];\n};\n\nconst pathSpec2pathname = (pathSpec: PathSpec) => {\n  if (pathSpec.some(({ type }) => type !== 'literal')) {\n    return undefined;\n  }\n  return '/' + pathSpec.map(({ name }) => name!).join('/');\n};\n\nexport function unstable_rerenderRoute(pathname: string, query?: string) {\n  const rscPath = encodeRoutePath(pathname);\n  getRerender()(rscPath, query && new URLSearchParams({ query }));\n}\n\nexport function unstable_notFound(): never {\n  throw createCustomError('Not Found', { status: 404 });\n}\n\nexport function unstable_redirect(\n  location: string,\n  status: 307 | 308 = 307,\n): never {\n  throw createCustomError('Redirect', { status, location });\n}\n\ntype SlotId = string;\n\nconst ROUTE_SLOT_ID_PREFIX = 'route:';\n\nexport function unstable_defineRouter(fns: {\n  getRouteConfig: () => Promise<\n    Iterable<{\n      path: PathSpec;\n      pathPattern?: PathSpec;\n      rootElement: { isStatic?: boolean };\n      routeElement: { isStatic?: boolean };\n      elements: Record<SlotId, { isStatic?: boolean }>;\n      noSsr?: boolean;\n    }>\n  >;\n  handleRoute: (\n    path: string,\n    options: {\n      query?: string;\n    },\n  ) => Promise<{\n    rootElement: ReactNode;\n    routeElement: ReactNode;\n    elements: Record<SlotId, unknown>;\n  }>;\n  getApiConfig?: () => Promise<\n    Iterable<{\n      path: PathSpec;\n      isStatic?: boolean;\n    }>\n  >;\n  handleApi?: (\n    path: string,\n    options: {\n      url: URL;\n      body: ReadableStream | null;\n      headers: Readonly<Record<string, string>>;\n      method: string;\n    },\n  ) => Promise<{\n    body?: ReadableStream;\n    headers?: Record<string, string | string[]>;\n    status?: number;\n  }>;\n}) {\n  type MyPathConfig = {\n    pathSpec: PathSpec;\n    pathname: string | undefined;\n    pattern: string;\n    specs: {\n      rootElementIsStatic?: true;\n      routeElementIsStatic?: true;\n      staticElementIds?: SlotId[];\n      isStatic?: true;\n      noSsr?: true;\n      is404?: true;\n      isApi?: true;\n    };\n  }[];\n  let cachedPathConfig: MyPathConfig | undefined;\n  const getMyPathConfig = async (): Promise<MyPathConfig> => {\n    const pathConfig = await unstable_getPlatformData(\n      'defineRouterPathConfigs',\n    );\n    if (pathConfig) {\n      return pathConfig as MyPathConfig;\n    }\n    if (!cachedPathConfig) {\n      cachedPathConfig = [\n        ...Array.from(await fns.getRouteConfig()).map((item) => {\n          const is404 =\n            item.path.length === 1 &&\n            item.path[0]!.type === 'literal' &&\n            item.path[0]!.name === '404';\n          const isStatic =\n            !!item.rootElement.isStatic &&\n            !!item.routeElement.isStatic &&\n            Object.values(item.elements).every((x) => x.isStatic);\n          return {\n            pathSpec: item.path,\n            pathname: pathSpec2pathname(item.path),\n            pattern: path2regexp(item.pathPattern || item.path),\n            specs: {\n              ...(item.rootElement.isStatic\n                ? { rootElementIsStatic: true as const }\n                : {}),\n              ...(item.routeElement.isStatic\n                ? { routeElementIsStatic: true as const }\n                : {}),\n              staticElementIds: Object.entries(item.elements).flatMap(\n                ([id, { isStatic }]) => (isStatic ? [id] : []),\n              ),\n              ...(isStatic ? { isStatic: true as const } : {}),\n              ...(is404 ? { is404: true as const } : {}),\n              ...(item.noSsr ? { noSsr: true as const } : {}),\n            },\n          };\n        }),\n        ...Array.from((await fns.getApiConfig?.()) || []).map((item) => {\n          return {\n            pathSpec: item.path,\n            pathname: pathSpec2pathname(item.path),\n            pattern: path2regexp(item.path),\n            specs: {\n              ...(item.isStatic ? { isStatic: true as const } : {}),\n              isApi: true as const,\n            },\n          };\n        }),\n      ];\n    }\n    return cachedPathConfig;\n  };\n  const getPathConfigItem = async (pathname: string) => {\n    const pathConfig = await getMyPathConfig();\n    const found = pathConfig.find(({ pathSpec }) =>\n      getPathMapping(pathSpec, pathname),\n    );\n    return found;\n  };\n  const has404 = async () => {\n    const pathConfig = await getMyPathConfig();\n    return pathConfig.some(({ specs: { is404 } }) => is404);\n  };\n  const getEntries = async (\n    rscPath: string,\n    rscParams: unknown,\n    headers: Readonly<Record<string, string>>,\n  ) => {\n    const pathname = decodeRoutePath(rscPath);\n    const pathConfigItem = await getPathConfigItem(pathname);\n    if (!pathConfigItem) {\n      return null;\n    }\n    let skipParam: unknown;\n    try {\n      skipParam = JSON.parse(headers[SKIP_HEADER.toLowerCase()] || '');\n    } catch {\n      // ignore\n    }\n    const skipIdSet = new Set(isStringArray(skipParam) ? skipParam : []);\n    const { query } = parseRscParams(rscParams);\n    const { rootElement, routeElement, elements } = await fns.handleRoute(\n      pathname,\n      pathConfigItem.specs.isStatic ? {} : { query },\n    );\n    if (\n      Object.keys(elements).some((id) => id.startsWith(ROUTE_SLOT_ID_PREFIX))\n    ) {\n      throw new Error('Element ID cannot start with \"route:\"');\n    }\n    const entries = {\n      ...elements,\n    };\n    for (const id of pathConfigItem.specs.staticElementIds || []) {\n      if (skipIdSet.has(id)) {\n        delete entries[id];\n      }\n    }\n    if (!pathConfigItem.specs.rootElementIsStatic || !skipIdSet.has('root')) {\n      entries.root = rootElement;\n    }\n    const decodedPathname = decodeURIComponent(pathname);\n    const routeId = ROUTE_SLOT_ID_PREFIX + decodedPathname;\n    if (!pathConfigItem.specs.routeElementIsStatic || !skipIdSet.has(routeId)) {\n      entries[routeId] = routeElement;\n    }\n    entries[ROUTE_ID] = [decodedPathname, query];\n    entries[IS_STATIC_ID] = !!pathConfigItem.specs.isStatic;\n    if (await has404()) {\n      entries[HAS404_ID] = true;\n    }\n    return entries;\n  };\n\n  type HandleRequest = Parameters<typeof defineEntries>[0]['handleRequest'];\n  type HandleBuild = Parameters<typeof defineEntries>[0]['handleBuild'];\n  type BuildConfig =\n    NonNullable<ReturnType<HandleBuild>> extends AsyncIterable<infer T>\n      ? T\n      : never;\n\n  const handleRequest: HandleRequest = async (\n    input,\n    { renderRsc, renderHtml },\n  ) => {\n    if (input.type === 'component') {\n      const entries = await getEntries(\n        input.rscPath,\n        input.rscParams,\n        input.req.headers,\n      );\n      if (!entries) {\n        return null;\n      }\n      return renderRsc(entries);\n    }\n    if (input.type === 'function') {\n      let elementsPromise: Promise<Record<string, unknown>> = Promise.resolve(\n        {},\n      );\n      let rendered = false;\n      const rerender = async (rscPath: string, rscParams?: unknown) => {\n        if (rendered) {\n          throw new Error('already rendered');\n        }\n        elementsPromise = Promise.all([\n          elementsPromise,\n          getEntries(rscPath, rscParams, input.req.headers),\n        ]).then(([oldElements, newElements]) => {\n          if (newElements === null) {\n            console.warn('getEntries returned null');\n          }\n          return {\n            ...oldElements,\n            ...newElements,\n          };\n        });\n      };\n      setRerender(rerender);\n      const value = await input.fn(...input.args);\n      rendered = true;\n      return renderRsc({ ...(await elementsPromise), _value: value });\n    }\n    const pathConfigItem = await getPathConfigItem(input.pathname);\n    if (pathConfigItem?.specs?.isApi && fns.handleApi) {\n      return fns.handleApi(input.pathname, {\n        url: input.req.url,\n        body: input.req.body,\n        headers: input.req.headers,\n        method: input.req.method,\n      });\n    }\n    if (input.type === 'action' || input.type === 'custom') {\n      const renderIt = async (pathname: string, query: string) => {\n        const rscPath = encodeRoutePath(pathname);\n        const rscParams = new URLSearchParams({ query });\n        const entries = await getEntries(rscPath, rscParams, input.req.headers);\n        if (!entries) {\n          return null;\n        }\n        const html = createElement(INTERNAL_ServerRouter, {\n          route: { path: pathname, query, hash: '' },\n        });\n        const actionResult =\n          input.type === 'action' ? await input.fn() : undefined;\n        return renderHtml(entries, html, { rscPath, actionResult });\n      };\n      const query = input.req.url.searchParams.toString();\n      if (pathConfigItem?.specs?.noSsr) {\n        return null;\n      }\n      try {\n        if (pathConfigItem) {\n          return await renderIt(input.pathname, query);\n        }\n      } catch (e) {\n        const info = getErrorInfo(e);\n        if (info?.status !== 404) {\n          throw e;\n        }\n      }\n      if (await has404()) {\n        return { ...(await renderIt('/404', '')), status: 404 };\n      } else {\n        return null;\n      }\n    }\n  };\n\n  type Tasks = Array<() => Promise<BuildConfig>>;\n  const handleBuild: HandleBuild = ({\n    renderRsc,\n    renderHtml,\n    rscPath2pathname,\n    unstable_generatePrefetchCode,\n    unstable_collectClientModules,\n  }) =>\n    createAsyncIterable(async (): Promise<Tasks> => {\n      const tasks: Tasks = [];\n      const pathConfig = await getMyPathConfig();\n\n      for (const { pathname, specs } of pathConfig) {\n        const { handleApi } = fns;\n        if (pathname && specs.isStatic && specs.isApi && handleApi) {\n          tasks.push(async () => ({\n            type: 'file',\n            pathname,\n            body: handleApi(pathname, {\n              url: new URL(pathname, 'http://localhost:3000'),\n              body: null,\n              headers: {},\n              method: 'GET',\n            }).then(({ body }) => body || stringToStream('')),\n          }));\n        }\n      }\n\n      const path2moduleIds: Record<string, string[]> = {};\n      const moduleIdsForPrefetch = new WeakMap<PathSpec, Set<string>>();\n      // FIXME this approach keeps all entries in memory during the loop\n      const entriesCache = new Map<string, Record<string, unknown>>();\n      await Promise.all(\n        pathConfig.map(async ({ pathSpec, pathname, pattern, specs }) => {\n          if (specs.isApi) {\n            return;\n          }\n          const moduleIds = new Set<string>();\n          moduleIdsForPrefetch.set(pathSpec, moduleIds);\n          if (!pathname) {\n            return;\n          }\n          const rscPath = encodeRoutePath(pathname);\n          const entries = await getEntries(rscPath, undefined, {});\n          if (entries) {\n            entriesCache.set(pathname, entries);\n            path2moduleIds[pattern] =\n              await unstable_collectClientModules(entries);\n            if (specs.isStatic) {\n              tasks.push(async () => ({\n                type: 'file',\n                pathname: rscPath2pathname(rscPath),\n                body: renderRsc(entries, {\n                  moduleIdCallback: (id) => moduleIds.add(id),\n                }),\n              }));\n            }\n          }\n        }),\n      );\n\n      const getRouterPrefetchCode = () => `\nglobalThis.__WAKU_ROUTER_PREFETCH__ = (path) => {\n  const path2ids = ${JSON.stringify(path2moduleIds)};\n  const pattern = Object.keys(path2ids).find((key) => new RegExp(key).test(path));\n  if (pattern && path2ids[pattern]) {\n    for (const id of path2ids[pattern] || []) {\n      import(id);\n    }\n  }\n};`;\n\n      for (const { pathSpec, pathname, specs } of pathConfig) {\n        if (specs.isApi) {\n          continue;\n        }\n        tasks.push(async () => {\n          const moduleIds = moduleIdsForPrefetch.get(pathSpec)!;\n          if (pathname) {\n            const rscPath = encodeRoutePath(pathname);\n            const code =\n              unstable_generatePrefetchCode([rscPath], moduleIds) +\n              getRouterPrefetchCode() +\n              (specs.is404 ? 'globalThis.__WAKU_ROUTER_404__ = true;' : '');\n            const entries = entriesCache.get(pathname);\n            if (specs.isStatic && entries) {\n              const html = createElement(INTERNAL_ServerRouter, {\n                route: { path: pathname, query: '', hash: '' },\n              });\n              return {\n                type: 'file',\n                pathname,\n                body: renderHtml(entries, html, {\n                  rscPath,\n                  htmlHead: `<script type=\"module\" async>${code}</script>`,\n                }).then(({ body }) => body),\n              };\n            }\n          }\n          const code =\n            unstable_generatePrefetchCode([], moduleIds) +\n            getRouterPrefetchCode() +\n            (specs.is404 ? 'globalThis.__WAKU_ROUTER_404__ = true;' : '');\n          return {\n            type: 'htmlHead',\n            pathSpec,\n            head: `<script type=\"module\" async>${code}</script>`,\n          };\n        });\n      }\n\n      await unstable_setPlatformData(\n        'defineRouterPathConfigs',\n        pathConfig,\n        true,\n      );\n      return tasks;\n    });\n\n  return defineEntries({ handleRequest, handleBuild });\n}\n"],"names":["createElement","unstable_getPlatformData","unstable_setPlatformData","unstable_createAsyncIterable","createAsyncIterable","unstable_defineEntries","defineEntries","encodeRoutePath","decodeRoutePath","ROUTE_ID","IS_STATIC_ID","HAS404_ID","SKIP_HEADER","getPathMapping","path2regexp","INTERNAL_ServerRouter","getContext","stringToStream","createCustomError","getErrorInfo","isStringArray","x","Array","isArray","every","y","parseRscParams","rscParams","URLSearchParams","query","get","RERENDER_SYMBOL","Symbol","setRerender","rerender","context","getRerender","pathSpec2pathname","pathSpec","some","type","undefined","map","name","join","unstable_rerenderRoute","pathname","rscPath","unstable_notFound","status","unstable_redirect","location","ROUTE_SLOT_ID_PREFIX","unstable_defineRouter","fns","cachedPathConfig","getMyPathConfig","pathConfig","from","getRouteConfig","item","is404","path","length","isStatic","rootElement","routeElement","Object","values","elements","pattern","pathPattern","specs","rootElementIsStatic","routeElementIsStatic","staticElementIds","entries","flatMap","id","noSsr","getApiConfig","isApi","getPathConfigItem","found","find","has404","getEntries","headers","pathConfigItem","skipParam","JSON","parse","toLowerCase","skipIdSet","Set","handleRoute","keys","startsWith","Error","has","root","decodedPathname","decodeURIComponent","routeId","handleRequest","input","renderRsc","renderHtml","req","elementsPromise","Promise","resolve","rendered","all","then","oldElements","newElements","console","warn","value","fn","args","_value","handleApi","url","body","method","renderIt","html","route","hash","actionResult","searchParams","toString","e","info","handleBuild","rscPath2pathname","unstable_generatePrefetchCode","unstable_collectClientModules","tasks","push","URL","path2moduleIds","moduleIdsForPrefetch","WeakMap","entriesCache","Map","moduleIds","set","moduleIdCallback","add","getRouterPrefetchCode","stringify","code","htmlHead","head"],"mappings":"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"}
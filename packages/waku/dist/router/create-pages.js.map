{"version":3,"sources":["../../src/router/create-pages.ts"],"sourcesContent":["import { createElement } from 'react';\nimport type { FunctionComponent, ReactNode } from 'react';\n\nimport { unstable_defineRouter } from './define-router.js';\nimport type { RouteProps } from './common.js';\nimport {\n  joinPath,\n  parsePathWithSlug,\n  getPathMapping,\n  pathSpecAsString,\n  parseExactPath,\n} from '../lib/utils/path.js';\nimport { getGrouplessPath } from '../lib/utils/create-pages.js';\nimport type { PathSpec } from '../lib/utils/path.js';\nimport type {\n  AnyPage,\n  GetSlugs,\n  PropsForPages,\n} from './create-pages-utils/inferred-path-types.js';\nimport { Children, Slot } from '../minimal/client.js';\nimport { ErrorBoundary } from '../router/client.js';\n\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods\nexport const METHODS = [\n  'GET',\n  'HEAD',\n  'POST',\n  'PUT',\n  'DELETE',\n  'CONNECT',\n  'OPTIONS',\n  'TRACE',\n  'PATCH',\n] as const;\nexport type Method = (typeof METHODS)[number];\n\nconst sanitizeSlug = (slug: string) =>\n  slug.replace(/\\./g, '').replace(/ /g, '-');\n\n// createPages API (a wrapper around unstable_defineRouter)\n\n/** Assumes that the path is a part of a slug path. */\ntype IsValidPathItem<T> = T extends `/${string}` | '[]' | '' ? false : true;\n/**\n * This is a helper type to check if a path is valid in a slug path.\n */\nexport type IsValidPathInSlugPath<T> = T extends `/${infer L}/${infer R}`\n  ? IsValidPathItem<L> extends true\n    ? IsValidPathInSlugPath<`/${R}`>\n    : false\n  : T extends `/${infer U}`\n    ? IsValidPathItem<U>\n    : false;\n/** Checks if a particular slug name exists in a path. */\nexport type HasSlugInPath<T, K extends string> = T extends `/[${K}]/${infer _}`\n  ? true\n  : T extends `/${infer _}/${infer U}`\n    ? HasSlugInPath<`/${U}`, K>\n    : T extends `/[${K}]`\n      ? true\n      : false;\n\nexport type HasWildcardInPath<T> = T extends `/[...${string}]/${string}`\n  ? true\n  : T extends `/${infer _}/${infer U}`\n    ? HasWildcardInPath<`/${U}`>\n    : T extends `/[...${string}]`\n      ? true\n      : false;\n\nexport type PathWithSlug<T, K extends string> =\n  IsValidPathInSlugPath<T> extends true\n    ? HasSlugInPath<T, K> extends true\n      ? T\n      : never\n    : never;\n\nexport type StaticSlugRoutePathsTuple<\n  T extends string,\n  Slugs extends unknown[] = GetSlugs<T>,\n  Result extends readonly string[] = [],\n> = Slugs extends []\n  ? Result\n  : Slugs extends [infer _, ...infer Rest]\n    ? StaticSlugRoutePathsTuple<T, Rest, readonly [...Result, string]>\n    : never;\n\ntype StaticSlugRoutePaths<T extends string> =\n  HasWildcardInPath<T> extends true\n    ? readonly string[] | readonly string[][]\n    : StaticSlugRoutePathsTuple<T> extends readonly [string]\n      ? readonly string[]\n      : StaticSlugRoutePathsTuple<T>[];\n\n/** Remove Slug from Path */\nexport type PathWithoutSlug<T> = T extends '/'\n  ? T\n  : IsValidPathInSlugPath<T> extends true\n    ? HasSlugInPath<T, string> extends true\n      ? never\n      : T\n    : never;\n\ntype PathWithStaticSlugs<T extends string> = T extends `/`\n  ? T\n  : IsValidPathInSlugPath<T> extends true\n    ? T\n    : never;\n\nexport type PathWithWildcard<\n  Path,\n  SlugKey extends string,\n  WildSlugKey extends string,\n> = PathWithSlug<Path, SlugKey | `...${WildSlugKey}`>;\n\nexport type CreatePage = <\n  Path extends string,\n  SlugKey extends string,\n  WildSlugKey extends string,\n  Render extends 'static' | 'dynamic',\n  StaticPaths extends StaticSlugRoutePaths<Path>,\n  ExactPath extends boolean | undefined = undefined,\n>(\n  page: (\n    | {\n        render: Extract<Render, 'static'>;\n        path: PathWithoutSlug<Path>;\n        component: FunctionComponent<PropsForPages<Path>>;\n      }\n    | ({\n        render: Extract<Render, 'static'>;\n        path: PathWithStaticSlugs<Path>;\n        component: FunctionComponent<PropsForPages<Path>>;\n      } & (ExactPath extends true ? {} : { staticPaths: StaticPaths }))\n    | {\n        render: Extract<Render, 'dynamic'>;\n        path: PathWithoutSlug<Path>;\n        component: FunctionComponent<PropsForPages<Path>>;\n      }\n    | {\n        render: Extract<Render, 'dynamic'>;\n        path: PathWithWildcard<Path, SlugKey, WildSlugKey>;\n        component: FunctionComponent<PropsForPages<Path>>;\n      }\n  ) & {\n    unstable_disableSSR?: boolean;\n    /**\n     * If true, the path will be matched exactly, without wildcards or slugs.\n     * This is intended for extending support to create custom routers.\n     */\n    exactPath?: ExactPath;\n  },\n) => Omit<\n  Exclude<typeof page, { path: never } | { render: never }>,\n  'unstable_disableSSR'\n>;\n\nexport type CreateLayout = <Path extends string>(\n  layout:\n    | {\n        render: 'dynamic';\n        path: Path;\n        component: FunctionComponent<\n          Pick<RouteProps, 'path'> & { children: ReactNode }\n        >;\n      }\n    | {\n        render: 'static';\n        path: Path;\n        component: FunctionComponent<{ children: ReactNode }>;\n      },\n) => void;\n\ntype ApiHandler = (req: Request) => Promise<Response>;\n\nexport type CreateApi = <Path extends string>(\n  params:\n    | {\n        render: 'static';\n        path: Path;\n        method: 'GET';\n        handler: ApiHandler;\n      }\n    | {\n        render: 'dynamic';\n        path: Path;\n        handlers: Partial<Record<Method, ApiHandler>>;\n      },\n) => void;\n\ntype RootItem = {\n  render: 'static' | 'dynamic';\n  component: FunctionComponent<{ children: ReactNode }>;\n};\n\nexport type CreateRoot = (root: RootItem) => void;\n\n/**\n * Root component for all pages\n * ```tsx\n *   <html>\n *     <head></head>\n *     <body>{children}</body>\n *   </html>\n * ```\n */\nconst DefaultRoot = ({ children }: { children: ReactNode }) =>\n  createElement(\n    ErrorBoundary,\n    null,\n    createElement(\n      'html',\n      null,\n      createElement('head', null),\n      createElement('body', null, children),\n    ),\n  );\n\nconst createNestedElements = (\n  elements: {\n    component: FunctionComponent<any>;\n    props?: Record<string, unknown>;\n  }[],\n) => {\n  return elements.reduceRight<ReactNode>(\n    (result, element) =>\n      createElement(element.component, element.props, result),\n    null,\n  );\n};\n\nexport const createPages = <\n  AllPages extends (AnyPage | ReturnType<CreateLayout>)[],\n>(\n  fn: (fns: {\n    createPage: CreatePage;\n    createLayout: CreateLayout;\n    createRoot: CreateRoot;\n    createApi: CreateApi;\n  }) => Promise<AllPages>,\n) => {\n  let configured = false;\n\n  // layout lookups retain (group) path and pathMaps store without group\n  // paths are stored without groups to easily detect duplicates\n  const groupPathLookup = new Map<string, string>();\n  const staticPathMap = new Map<\n    string,\n    { literalSpec: PathSpec; originalSpec?: PathSpec }\n  >();\n  const dynamicPagePathMap = new Map<\n    string,\n    [PathSpec, FunctionComponent<any>]\n  >();\n  const wildcardPagePathMap = new Map<\n    string,\n    [PathSpec, FunctionComponent<any>]\n  >();\n  const dynamicLayoutPathMap = new Map<\n    string,\n    [PathSpec, FunctionComponent<any>]\n  >();\n  const apiPathMap = new Map<\n    string, // `${method} ${path}`\n    {\n      render: 'static' | 'dynamic';\n      pathSpec: PathSpec;\n      handlers: Partial<Record<Method, ApiHandler>>;\n    }\n  >();\n  const staticComponentMap = new Map<string, FunctionComponent<any>>();\n  let rootItem: RootItem | undefined = undefined;\n  const noSsrSet = new WeakSet<PathSpec>();\n\n  /** helper to find dynamic path when slugs are used */\n  const getPageRoutePath: (path: string) => string | undefined = (path) => {\n    if (staticComponentMap.has(joinPath(path, 'page').slice(1))) {\n      return path;\n    }\n    const allPaths = [\n      ...dynamicPagePathMap.keys(),\n      ...wildcardPagePathMap.keys(),\n    ];\n    for (const p of allPaths) {\n      if (getPathMapping(parsePathWithSlug(p), path)) {\n        return p;\n      }\n    }\n  };\n\n  const getApiRoutePath: (\n    path: string,\n    method: string,\n  ) => string | undefined = (path, method) => {\n    for (const [p, v] of apiPathMap.entries()) {\n      if (method in v.handlers && getPathMapping(parsePathWithSlug(p!), path)) {\n        return p;\n      }\n    }\n  };\n\n  const pagePathExists = (path: string) => {\n    for (const pathKey of apiPathMap.keys()) {\n      const [_m, p] = pathKey.split(' ');\n      if (p === path) {\n        return true;\n      }\n    }\n    return (\n      staticPathMap.has(path) ||\n      dynamicPagePathMap.has(path) ||\n      wildcardPagePathMap.has(path)\n    );\n  };\n\n  /** helper to get original static slug path */\n  const getOriginalStaticPathSpec = (path: string) => {\n    const staticPathSpec = staticPathMap.get(path);\n    if (staticPathSpec) {\n      return staticPathSpec.originalSpec ?? staticPathSpec.literalSpec;\n    }\n  };\n\n  const registerStaticComponent = (\n    id: string,\n    component: FunctionComponent<any>,\n  ) => {\n    if (\n      staticComponentMap.has(id) &&\n      staticComponentMap.get(id) !== component\n    ) {\n      throw new Error(`Duplicated component for: ${id}`);\n    }\n    staticComponentMap.set(id, component);\n  };\n\n  const createPage: CreatePage = (page) => {\n    if (configured) {\n      throw new Error('createPage no longer available');\n    }\n    if (pagePathExists(page.path)) {\n      throw new Error(`Duplicated path: ${page.path}`);\n    }\n\n    const pathSpec = parsePathWithSlug(page.path);\n    if (page.unstable_disableSSR) {\n      noSsrSet.add(pathSpec);\n    }\n    const { numSlugs, numWildcards } = (() => {\n      let numSlugs = 0;\n      let numWildcards = 0;\n      for (const slug of pathSpec) {\n        if (slug.type !== 'literal') {\n          numSlugs++;\n        }\n        if (slug.type === 'wildcard') {\n          numWildcards++;\n        }\n      }\n      return { numSlugs, numWildcards };\n    })();\n\n    if (page.exactPath) {\n      const spec = parseExactPath(page.path);\n      if (page.render === 'static') {\n        staticPathMap.set(page.path, {\n          literalSpec: spec,\n        });\n        const id = joinPath(page.path, 'page').replace(/^\\//, '');\n        registerStaticComponent(id, page.component);\n      } else {\n        dynamicPagePathMap.set(page.path, [spec, page.component]);\n      }\n    } else if (page.render === 'static' && numSlugs === 0) {\n      const pagePath = getGrouplessPath(page.path);\n      staticPathMap.set(pagePath, {\n        literalSpec: pathSpec,\n      });\n      const id = joinPath(pagePath, 'page').replace(/^\\//, '');\n      if (pagePath !== page.path) {\n        groupPathLookup.set(pagePath, page.path);\n      }\n      registerStaticComponent(id, page.component);\n    } else if (\n      page.render === 'static' &&\n      numSlugs > 0 &&\n      'staticPaths' in page\n    ) {\n      const staticPaths = page.staticPaths.map((item) =>\n        (Array.isArray(item) ? item : [item]).map(sanitizeSlug),\n      );\n      for (const staticPath of staticPaths) {\n        if (staticPath.length !== numSlugs && numWildcards === 0) {\n          throw new Error('staticPaths does not match with slug pattern');\n        }\n        const mapping: Record<string, string | string[]> = {};\n        let slugIndex = 0;\n        const pathItems: string[] = [];\n        pathSpec.forEach(({ type, name }) => {\n          switch (type) {\n            case 'literal':\n              pathItems.push(name!);\n              break;\n            case 'wildcard':\n              mapping[name!] = staticPath.slice(slugIndex);\n              staticPath.slice(slugIndex++).forEach((slug) => {\n                pathItems.push(slug);\n              });\n              break;\n            case 'group':\n              pathItems.push(staticPath[slugIndex++]!);\n              mapping[name!] = pathItems[pathItems.length - 1]!;\n              break;\n          }\n        });\n        const definedPath = '/' + pathItems.join('/');\n        const pagePath = getGrouplessPath(definedPath);\n        staticPathMap.set(pagePath, {\n          literalSpec: pathItems.map((name) => ({ type: 'literal', name })),\n          originalSpec: pathSpec,\n        });\n        if (pagePath !== definedPath) {\n          groupPathLookup.set(pagePath, definedPath);\n        }\n        const id = joinPath(...pathItems, 'page');\n        const WrappedComponent = (props: Record<string, unknown>) =>\n          createElement(page.component as any, { ...props, ...mapping });\n        registerStaticComponent(id, WrappedComponent);\n      }\n    } else if (page.render === 'dynamic' && numWildcards === 0) {\n      const pagePath = getGrouplessPath(page.path);\n      if (pagePath !== page.path) {\n        groupPathLookup.set(pagePath, page.path);\n      }\n      dynamicPagePathMap.set(pagePath, [pathSpec, page.component]);\n    } else if (page.render === 'dynamic' && numWildcards === 1) {\n      const pagePath = getGrouplessPath(page.path);\n      if (pagePath !== page.path) {\n        groupPathLookup.set(pagePath, page.path);\n      }\n      wildcardPagePathMap.set(pagePath, [pathSpec, page.component]);\n    } else {\n      throw new Error('Invalid page configuration');\n    }\n    return page as Exclude<typeof page, { path: never } | { render: never }>;\n  };\n\n  const createLayout: CreateLayout = (layout) => {\n    if (configured) {\n      throw new Error('createLayout no longer available');\n    }\n    if (layout.render === 'static') {\n      const id = joinPath(layout.path, 'layout').replace(/^\\//, '');\n      registerStaticComponent(id, layout.component);\n    } else if (layout.render === 'dynamic') {\n      if (dynamicLayoutPathMap.has(layout.path)) {\n        throw new Error(`Duplicated dynamic path: ${layout.path}`);\n      }\n      const pathSpec = parsePathWithSlug(layout.path);\n      dynamicLayoutPathMap.set(layout.path, [pathSpec, layout.component]);\n    } else {\n      throw new Error('Invalid layout configuration');\n    }\n  };\n\n  const createApi: CreateApi = (options) => {\n    if (!import.meta.env.VITE_EXPERIMENTAL_WAKU_ROUTER) {\n      console.warn('createApi is still experimental');\n      return;\n    }\n    if (configured) {\n      throw new Error('createApi no longer available');\n    }\n    if (apiPathMap.has(options.path)) {\n      throw new Error(`Duplicated api path: ${options.path}`);\n    }\n    const pathSpec = parsePathWithSlug(options.path);\n    if (options.render === 'static') {\n      apiPathMap.set(options.path, {\n        render: 'static',\n        pathSpec,\n        handlers: { GET: options.handler },\n      });\n    } else {\n      apiPathMap.set(options.path, {\n        render: 'dynamic',\n        pathSpec,\n        handlers: options.handlers,\n      });\n    }\n  };\n\n  const createRoot: CreateRoot = (root) => {\n    if (configured) {\n      throw new Error('createRoot no longer available');\n    }\n    if (rootItem) {\n      throw new Error(`Duplicated root component`);\n    }\n    if (root.render === 'static' || root.render === 'dynamic') {\n      rootItem = root;\n    } else {\n      throw new Error('Invalid root configuration');\n    }\n  };\n\n  let ready: Promise<AllPages | void> | undefined;\n  const configure = async () => {\n    if (!configured && !ready) {\n      ready = fn({ createPage, createLayout, createRoot, createApi });\n      await ready;\n      configured = true;\n    }\n    await ready;\n  };\n\n  const getLayouts = (spec: PathSpec): string[] => {\n    const pathSegments = spec.reduce<string[]>(\n      (acc, _segment, index) => {\n        acc.push(pathSpecAsString(spec.slice(0, index + 1)));\n        return acc;\n      },\n      ['/'],\n    );\n\n    return pathSegments.filter(\n      (segment) =>\n        dynamicLayoutPathMap.has(segment) ||\n        staticComponentMap.has(joinPath(segment, 'layout').slice(1)), // feels like a hack\n    );\n  };\n\n  const definedRouter = unstable_defineRouter({\n    getRouteConfig: async () => {\n      await configure();\n      const paths: {\n        path: PathSpec;\n        pathPattern?: PathSpec;\n        rootElement: { isStatic?: boolean };\n        routeElement: { isStatic?: boolean };\n        elements: Record<string, { isStatic?: boolean }>;\n        noSsr: boolean;\n      }[] = [];\n      const rootIsStatic = !rootItem || rootItem.render === 'static';\n      for (const [path, { literalSpec, originalSpec }] of staticPathMap) {\n        const noSsr = noSsrSet.has(literalSpec);\n\n        const layoutPaths = getLayouts(originalSpec ?? literalSpec);\n\n        const elements = {\n          ...layoutPaths.reduce<Record<string, { isStatic: boolean }>>(\n            (acc, lPath) => {\n              acc[`layout:${lPath}`] = {\n                isStatic: !dynamicLayoutPathMap.has(lPath),\n              };\n              return acc;\n            },\n            {},\n          ),\n          [`page:${path}`]: { isStatic: staticPathMap.has(path) },\n        };\n\n        paths.push({\n          path: literalSpec.filter((part) => !part.name?.startsWith('(')),\n          ...(originalSpec && { pathPattern: originalSpec }),\n          rootElement: { isStatic: rootIsStatic },\n          routeElement: {\n            isStatic: true,\n          },\n          elements,\n          noSsr,\n        });\n      }\n      for (const [path, [pathSpec]] of dynamicPagePathMap) {\n        const noSsr = noSsrSet.has(pathSpec);\n        const layoutPaths = getLayouts(pathSpec);\n        const elements = {\n          ...layoutPaths.reduce<Record<string, { isStatic: boolean }>>(\n            (acc, lPath) => {\n              acc[`layout:${lPath}`] = {\n                isStatic: !dynamicLayoutPathMap.has(lPath),\n              };\n              return acc;\n            },\n            {},\n          ),\n          [`page:${path}`]: { isStatic: false },\n        };\n        paths.push({\n          path: pathSpec.filter((part) => !part.name?.startsWith('(')),\n          rootElement: { isStatic: rootIsStatic },\n          routeElement: { isStatic: true },\n          elements,\n          noSsr,\n        });\n      }\n      for (const [path, [pathSpec]] of wildcardPagePathMap) {\n        const noSsr = noSsrSet.has(pathSpec);\n        const layoutPaths = getLayouts(pathSpec);\n        const elements = {\n          ...layoutPaths.reduce<Record<string, { isStatic: boolean }>>(\n            (acc, lPath) => {\n              acc[`layout:${lPath}`] = {\n                isStatic: !dynamicLayoutPathMap.has(lPath),\n              };\n              return acc;\n            },\n            {},\n          ),\n          [`page:${path}`]: { isStatic: false },\n        };\n        paths.push({\n          path: pathSpec.filter((part) => !part.name?.startsWith('(')),\n          rootElement: { isStatic: rootIsStatic },\n          routeElement: { isStatic: true },\n          elements,\n          noSsr,\n        });\n      }\n      return paths;\n    },\n    handleRoute: async (path, { query }) => {\n      await configure();\n\n      // path without slugs\n      const routePath = getPageRoutePath(path);\n      if (!routePath) {\n        throw new Error('Route not found: ' + path);\n      }\n\n      const pageComponent =\n        staticComponentMap.get(joinPath(routePath, 'page').slice(1)) ??\n        dynamicPagePathMap.get(routePath)?.[1] ??\n        wildcardPagePathMap.get(routePath)?.[1];\n\n      if (!pageComponent) {\n        throw new Error('Page not found: ' + path);\n      }\n\n      const layoutMatchPath = groupPathLookup.get(routePath) ?? routePath;\n      const pathSpec = parsePathWithSlug(layoutMatchPath);\n      const mapping = getPathMapping(pathSpec, path);\n      const result: Record<string, unknown> = {\n        [`page:${routePath}`]: createElement(\n          pageComponent,\n          { ...mapping, ...(query ? { query } : {}), path },\n          createElement(Children),\n        ),\n      };\n\n      const layoutPaths = getLayouts(\n        getOriginalStaticPathSpec(path) ?? pathSpec,\n      );\n\n      for (const segment of layoutPaths) {\n        const layout =\n          dynamicLayoutPathMap.get(segment)?.[1] ??\n          staticComponentMap.get(joinPath(segment, 'layout').slice(1)); // feels like a hack\n\n        const isDynamic = dynamicLayoutPathMap.has(segment);\n\n        // always true\n        if (layout) {\n          const id = 'layout:' + segment;\n          result[id] = createElement(\n            layout,\n            isDynamic ? { path } : null,\n            createElement(Children),\n          );\n        }\n      }\n\n      // loop over all layouts for path\n      const routeChildren = [\n        ...layoutPaths.map((lPath) => ({\n          component: Slot,\n          props: { id: `layout:${lPath}` },\n        })),\n        { component: Slot, props: { id: `page:${routePath}` } },\n      ];\n\n      return {\n        elements: result,\n        rootElement: createElement(\n          rootItem ? rootItem.component : DefaultRoot,\n          null,\n          createElement(Children),\n        ),\n        routeElement: createNestedElements(routeChildren),\n      };\n    },\n    getApiConfig: async () => {\n      await configure();\n\n      return Array.from(apiPathMap.values()).map(({ pathSpec, render }) => {\n        return {\n          path: pathSpec,\n          isStatic: render === 'static',\n        };\n      });\n    },\n    handleApi: async (path, { url, ...options }) => {\n      await configure();\n      const routePath = getApiRoutePath(path, options.method);\n      if (!routePath) {\n        throw new Error('API Route not found: ' + path);\n      }\n      const { handlers } = apiPathMap.get(routePath)!;\n      const req = new Request(url, options);\n      const handler = handlers[options.method as Method];\n      if (!handler) {\n        throw new Error(\n          'API method not found: ' + options.method + 'for path: ' + path,\n        );\n      }\n      const res = await handler(req);\n\n      return {\n        ...(res.body ? { body: res.body } : {}),\n        headers: Object.fromEntries(res.headers.entries()),\n        status: res.status,\n      };\n    },\n  });\n\n  return definedRouter as typeof definedRouter & {\n    /** This for type inference of the router only. We do not actually return anything for this type. */\n    DO_NOT_USE_pages: Exclude<\n      Exclude<Awaited<Exclude<typeof ready, undefined>>, void>[number],\n      void // createLayout returns void\n    >;\n  };\n};\n"],"names":["createElement","unstable_defineRouter","joinPath","parsePathWithSlug","getPathMapping","pathSpecAsString","parseExactPath","getGrouplessPath","Children","Slot","ErrorBoundary","METHODS","sanitizeSlug","slug","replace","DefaultRoot","children","createNestedElements","elements","reduceRight","result","element","component","props","createPages","fn","configured","groupPathLookup","Map","staticPathMap","dynamicPagePathMap","wildcardPagePathMap","dynamicLayoutPathMap","apiPathMap","staticComponentMap","rootItem","undefined","noSsrSet","WeakSet","getPageRoutePath","path","has","slice","allPaths","keys","p","getApiRoutePath","method","v","entries","handlers","pagePathExists","pathKey","_m","split","getOriginalStaticPathSpec","staticPathSpec","get","originalSpec","literalSpec","registerStaticComponent","id","Error","set","createPage","page","pathSpec","unstable_disableSSR","add","numSlugs","numWildcards","type","exactPath","spec","render","pagePath","staticPaths","map","item","Array","isArray","staticPath","length","mapping","slugIndex","pathItems","forEach","name","push","definedPath","join","WrappedComponent","createLayout","layout","createApi","options","env","VITE_EXPERIMENTAL_WAKU_ROUTER","console","warn","GET","handler","createRoot","root","ready","configure","getLayouts","pathSegments","reduce","acc","_segment","index","filter","segment","definedRouter","getRouteConfig","paths","rootIsStatic","noSsr","layoutPaths","lPath","isStatic","part","startsWith","pathPattern","rootElement","routeElement","handleRoute","query","routePath","pageComponent","layoutMatchPath","isDynamic","routeChildren","getApiConfig","from","values","handleApi","url","req","Request","res","body","headers","Object","fromEntries","status"],"mappings":"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"}
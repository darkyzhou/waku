{"version":3,"sources":["../../src/router/create-pages.ts"],"sourcesContent":["import { createElement, Fragment } from 'react';\nimport type { FunctionComponent, ReactNode } from 'react';\n\nimport { unstable_defineRouter } from './define-router.js';\nimport type { RouteProps } from './common.js';\nimport {\n  joinPath,\n  parsePathWithSlug,\n  getPathMapping,\n  pathSpecAsString,\n  parseExactPath,\n} from '../lib/utils/path.js';\nimport { getGrouplessPath } from '../lib/utils/create-pages.js';\nimport type { PathSpec } from '../lib/utils/path.js';\nimport type {\n  AnyPage,\n  GetSlugs,\n  PropsForPages,\n} from './create-pages-utils/inferred-path-types.js';\nimport { Children, Slot } from '../minimal/client.js';\nimport { ErrorBoundary } from '../router/client.js';\n\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods\nexport const METHODS = [\n  'GET',\n  'HEAD',\n  'POST',\n  'PUT',\n  'DELETE',\n  'CONNECT',\n  'OPTIONS',\n  'TRACE',\n  'PATCH',\n] as const;\nexport type Method = (typeof METHODS)[number];\n\nconst sanitizeSlug = (slug: string) =>\n  slug.replace(/\\./g, '').replace(/ /g, '-');\n\n// createPages API (a wrapper around unstable_defineRouter)\n\n/** Assumes that the path is a part of a slug path. */\ntype IsValidPathItem<T> = T extends `/${string}` | '[]' | '' ? false : true;\n/**\n * This is a helper type to check if a path is valid in a slug path.\n */\nexport type IsValidPathInSlugPath<T> = T extends `/${infer L}/${infer R}`\n  ? IsValidPathItem<L> extends true\n    ? IsValidPathInSlugPath<`/${R}`>\n    : false\n  : T extends `/${infer U}`\n    ? IsValidPathItem<U>\n    : false;\n/** Checks if a particular slug name exists in a path. */\nexport type HasSlugInPath<T, K extends string> = T extends `/[${K}]/${infer _}`\n  ? true\n  : T extends `/${infer _}/${infer U}`\n    ? HasSlugInPath<`/${U}`, K>\n    : T extends `/[${K}]`\n      ? true\n      : false;\n\nexport type HasWildcardInPath<T> = T extends `/[...${string}]/${string}`\n  ? true\n  : T extends `/${infer _}/${infer U}`\n    ? HasWildcardInPath<`/${U}`>\n    : T extends `/[...${string}]`\n      ? true\n      : false;\n\nexport type PathWithSlug<T, K extends string> =\n  IsValidPathInSlugPath<T> extends true\n    ? HasSlugInPath<T, K> extends true\n      ? T\n      : never\n    : never;\n\nexport type StaticSlugRoutePathsTuple<\n  T extends string,\n  Slugs extends unknown[] = GetSlugs<T>,\n  Result extends readonly string[] = [],\n> = Slugs extends []\n  ? Result\n  : Slugs extends [infer _, ...infer Rest]\n    ? StaticSlugRoutePathsTuple<T, Rest, readonly [...Result, string]>\n    : never;\n\ntype StaticSlugRoutePaths<T extends string> =\n  HasWildcardInPath<T> extends true\n    ? readonly string[] | readonly string[][]\n    : StaticSlugRoutePathsTuple<T> extends readonly [string]\n      ? readonly string[]\n      : StaticSlugRoutePathsTuple<T>[];\n\n/** Remove Slug from Path */\nexport type PathWithoutSlug<T> = T extends '/'\n  ? T\n  : IsValidPathInSlugPath<T> extends true\n    ? HasSlugInPath<T, string> extends true\n      ? never\n      : T\n    : never;\n\ntype PathWithStaticSlugs<T extends string> = T extends `/`\n  ? T\n  : IsValidPathInSlugPath<T> extends true\n    ? T\n    : never;\n\nexport type PathWithWildcard<\n  Path,\n  SlugKey extends string,\n  WildSlugKey extends string,\n> = PathWithSlug<Path, SlugKey | `...${WildSlugKey}`>;\n\nexport type CreatePage = <\n  Path extends string,\n  SlugKey extends string,\n  WildSlugKey extends string,\n  Render extends 'static' | 'dynamic',\n  StaticPaths extends StaticSlugRoutePaths<Path>,\n  ExactPath extends boolean | undefined = undefined,\n>(\n  page: (\n    | {\n        render: Extract<Render, 'static'>;\n        path: PathWithoutSlug<Path>;\n        component: FunctionComponent<PropsForPages<Path>>;\n      }\n    | ({\n        render: Extract<Render, 'static'>;\n        path: PathWithStaticSlugs<Path>;\n        component: FunctionComponent<PropsForPages<Path>>;\n      } & (ExactPath extends true ? {} : { staticPaths: StaticPaths }))\n    | {\n        render: Extract<Render, 'dynamic'>;\n        path: PathWithoutSlug<Path>;\n        component: FunctionComponent<PropsForPages<Path>>;\n      }\n    | {\n        render: Extract<Render, 'dynamic'>;\n        path: PathWithWildcard<Path, SlugKey, WildSlugKey>;\n        component: FunctionComponent<PropsForPages<Path>>;\n      }\n  ) & {\n    unstable_disableSSR?: boolean;\n    /**\n     * If true, the path will be matched exactly, without wildcards or slugs.\n     * This is intended for extending support to create custom routers.\n     */\n    exactPath?: ExactPath;\n  },\n) => Omit<\n  Exclude<typeof page, { path: never } | { render: never }>,\n  'unstable_disableSSR'\n>;\n\nexport type CreateLayout = <Path extends string>(\n  layout:\n    | {\n        render: 'dynamic';\n        path: Path;\n        component: FunctionComponent<\n          Pick<RouteProps, 'path'> & { children: ReactNode }\n        >;\n      }\n    | {\n        render: 'static';\n        path: Path;\n        component: FunctionComponent<{ children: ReactNode }>;\n      },\n) => void;\n\ntype ApiHandler = (req: Request) => Promise<Response>;\n\nexport type CreateApi = <Path extends string>(\n  params:\n    | {\n        render: 'static';\n        path: Path;\n        method: 'GET';\n        handler: ApiHandler;\n      }\n    | {\n        render: 'dynamic';\n        path: Path;\n        /**\n         * Handlers by named method. Use `all` to handle all methods.\n         * Named methods will take precedence over `all`.\n         */\n        handlers: Partial<Record<Method | 'all', ApiHandler>>;\n      },\n) => void;\n\nexport type CreatePagePart = <const Path extends string>(params: {\n  path: Path;\n  render: 'static' | 'dynamic';\n  order: number;\n  component: FunctionComponent<{ children: ReactNode }>;\n}) => typeof params;\n\ntype RootItem = {\n  render: 'static' | 'dynamic';\n  component: FunctionComponent<{ children: ReactNode }>;\n};\n\nexport type CreateRoot = (root: RootItem) => void;\n\n/**\n * Root component for all pages\n * ```tsx\n *   <html>\n *     <head></head>\n *     <body>{children}</body>\n *   </html>\n * ```\n */\nconst DefaultRoot = ({ children }: { children: ReactNode }) =>\n  createElement(\n    ErrorBoundary,\n    null,\n    createElement(\n      'html',\n      null,\n      createElement('head', null),\n      createElement('body', null, children),\n    ),\n  );\n\nconst createNestedElements = (\n  elements: {\n    component: FunctionComponent<any>;\n    props?: Record<string, unknown>;\n  }[],\n  children: ReactNode,\n) => {\n  return elements.reduceRight<ReactNode>(\n    (result, element) =>\n      createElement(element.component, element.props, result),\n    children,\n  );\n};\n\ntype ComponentList = {\n  render: 'static' | 'dynamic';\n  component: FunctionComponent<any>;\n}[];\n\ntype ComponentEntry = FunctionComponent<any> | ComponentList;\n\nexport const createPages = <\n  AllPages extends (AnyPage | ReturnType<CreateLayout>)[],\n>(\n  fn: (fns: {\n    createPage: CreatePage;\n    createLayout: CreateLayout;\n    createRoot: CreateRoot;\n    createApi: CreateApi;\n    /**\n     * Page Part pages will be dynamic when any part is dynamic.\n     * If all parts are static, the page will be static.\n     */\n    createPagePart: CreatePagePart;\n  }) => Promise<AllPages>,\n) => {\n  let configured = false;\n\n  // layout lookups retain (group) path and pathMaps store without group\n  // paths are stored without groups to easily detect duplicates\n  const groupPathLookup = new Map<string, string>();\n  const staticPathMap = new Map<\n    string,\n    { literalSpec: PathSpec; originalSpec?: PathSpec }\n  >();\n  const pagePartRenderModeMap = new Map<string, 'static' | 'dynamic'>();\n  const staticPagePartRoutes = new Set<string>();\n  const dynamicPagePathMap = new Map<string, [PathSpec, ComponentEntry]>();\n  const wildcardPagePathMap = new Map<string, [PathSpec, ComponentEntry]>();\n  const dynamicLayoutPathMap = new Map<string, [PathSpec, ComponentEntry]>();\n  const apiPathMap = new Map<\n    string, // `${method} ${path}`\n    {\n      render: 'static' | 'dynamic';\n      pathSpec: PathSpec;\n      handlers: Partial<Record<Method | 'all', ApiHandler>>;\n    }\n  >();\n  const staticComponentMap = new Map<string, FunctionComponent<any>>();\n  let rootItem: RootItem | undefined = undefined;\n  const noSsrSet = new WeakSet<PathSpec>();\n\n  /** helper to find dynamic path when slugs are used */\n  const getPageRoutePath: (path: string) => string | undefined = (path) => {\n    if (\n      staticComponentMap.has(joinPath(path, 'page').slice(1)) ||\n      staticPagePartRoutes.has(path)\n    ) {\n      return path;\n    }\n    const allPaths = [\n      ...dynamicPagePathMap.keys(),\n      ...wildcardPagePathMap.keys(),\n    ];\n    for (const p of allPaths) {\n      if (getPathMapping(parsePathWithSlug(p), path)) {\n        return p;\n      }\n    }\n  };\n\n  const getApiRoutePath: (\n    path: string,\n    method: string,\n  ) => string | undefined = (path, method) => {\n    for (const [p, v] of apiPathMap.entries()) {\n      if (\n        (method in v.handlers || v.handlers.all) &&\n        getPathMapping(parsePathWithSlug(p!), path)\n      ) {\n        return p;\n      }\n    }\n  };\n\n  const pagePathExists = (path: string) => {\n    for (const pathKey of apiPathMap.keys()) {\n      const [_m, p] = pathKey.split(' ');\n      if (p === path) {\n        return true;\n      }\n    }\n    return (\n      staticPathMap.has(path) ||\n      dynamicPagePathMap.has(path) ||\n      wildcardPagePathMap.has(path)\n    );\n  };\n\n  /** helper to get original static slug path */\n  const getOriginalStaticPathSpec = (path: string) => {\n    const staticPathSpec = staticPathMap.get(path);\n    if (staticPathSpec) {\n      return staticPathSpec.originalSpec ?? staticPathSpec.literalSpec;\n    }\n  };\n\n  const registerStaticComponent = (\n    id: string,\n    component: FunctionComponent<any>,\n  ) => {\n    if (\n      staticComponentMap.has(id) &&\n      staticComponentMap.get(id) !== component\n    ) {\n      throw new Error(`Duplicated component for: ${id}`);\n    }\n    staticComponentMap.set(id, component);\n  };\n\n  const createPage: CreatePage = (page) => {\n    if (configured) {\n      throw new Error('createPage no longer available');\n    }\n    if (pagePathExists(page.path)) {\n      throw new Error(`Duplicated path: ${page.path}`);\n    }\n\n    const pathSpec = parsePathWithSlug(page.path);\n    const { numSlugs, numWildcards } = getSlugsAndWildcards(pathSpec);\n    if (page.unstable_disableSSR) {\n      noSsrSet.add(pathSpec);\n    }\n\n    if (page.exactPath) {\n      const spec = parseExactPath(page.path);\n      if (page.render === 'static') {\n        staticPathMap.set(page.path, {\n          literalSpec: spec,\n        });\n        const id = joinPath(page.path, 'page').replace(/^\\//, '');\n        if (page.component) {\n          registerStaticComponent(id, page.component);\n        }\n      } else if (page.component) {\n        dynamicPagePathMap.set(page.path, [spec, page.component]);\n      } else {\n        dynamicPagePathMap.set(page.path, [spec, []]);\n      }\n    } else if (page.render === 'static' && numSlugs === 0) {\n      const pagePath = getGrouplessPath(page.path);\n      staticPathMap.set(pagePath, {\n        literalSpec: pathSpec,\n      });\n      const id = joinPath(pagePath, 'page').replace(/^\\//, '');\n      if (pagePath !== page.path) {\n        groupPathLookup.set(pagePath, page.path);\n      }\n      if (page.component) {\n        registerStaticComponent(id, page.component);\n      }\n    } else if (\n      page.render === 'static' &&\n      numSlugs > 0 &&\n      'staticPaths' in page\n    ) {\n      const staticPaths = page.staticPaths.map((item) =>\n        (Array.isArray(item) ? item : [item]).map(sanitizeSlug),\n      );\n      for (const staticPath of staticPaths) {\n        if (staticPath.length !== numSlugs && numWildcards === 0) {\n          throw new Error('staticPaths does not match with slug pattern');\n        }\n        const mapping: Record<string, string | string[]> = {};\n        let slugIndex = 0;\n        const pathItems: string[] = [];\n        pathSpec.forEach(({ type, name }) => {\n          switch (type) {\n            case 'literal':\n              pathItems.push(name!);\n              break;\n            case 'wildcard':\n              mapping[name!] = staticPath.slice(slugIndex);\n              staticPath.slice(slugIndex++).forEach((slug) => {\n                pathItems.push(slug);\n              });\n              break;\n            case 'group':\n              pathItems.push(staticPath[slugIndex++]!);\n              mapping[name!] = pathItems[pathItems.length - 1]!;\n              break;\n          }\n        });\n        const definedPath = '/' + pathItems.join('/');\n        const pagePath = getGrouplessPath(definedPath);\n        staticPathMap.set(pagePath, {\n          literalSpec: pathItems.map((name) => ({ type: 'literal', name })),\n          originalSpec: pathSpec,\n        });\n        if (pagePath !== definedPath) {\n          groupPathLookup.set(pagePath, definedPath);\n        }\n        const id = joinPath(...pathItems, 'page');\n        const WrappedComponent = (props: Record<string, unknown>) =>\n          createElement(page.component as any, { ...props, ...mapping });\n        registerStaticComponent(id, WrappedComponent);\n      }\n    } else if (page.render === 'dynamic' && numWildcards === 0) {\n      const pagePath = getGrouplessPath(page.path);\n      if (pagePath !== page.path) {\n        groupPathLookup.set(pagePath, page.path);\n      }\n      dynamicPagePathMap.set(pagePath, [pathSpec, page.component]);\n    } else if (page.render === 'dynamic' && numWildcards === 1) {\n      const pagePath = getGrouplessPath(page.path);\n      if (pagePath !== page.path) {\n        groupPathLookup.set(pagePath, page.path);\n      }\n      wildcardPagePathMap.set(pagePath, [pathSpec, page.component]);\n    } else {\n      throw new Error('Invalid page configuration');\n    }\n    return page as Exclude<typeof page, { path: never } | { render: never }>;\n  };\n\n  const createLayout: CreateLayout = (layout) => {\n    if (configured) {\n      throw new Error('createLayout no longer available');\n    }\n    if (layout.render === 'static') {\n      const id = joinPath(layout.path, 'layout').replace(/^\\//, '');\n      registerStaticComponent(id, layout.component);\n    } else if (layout.render === 'dynamic') {\n      if (dynamicLayoutPathMap.has(layout.path)) {\n        throw new Error(`Duplicated dynamic path: ${layout.path}`);\n      }\n      const pathSpec = parsePathWithSlug(layout.path);\n      dynamicLayoutPathMap.set(layout.path, [pathSpec, layout.component]);\n    } else {\n      throw new Error('Invalid layout configuration');\n    }\n  };\n\n  const createApi: CreateApi = (options) => {\n    if (configured) {\n      throw new Error('createApi no longer available');\n    }\n    if (apiPathMap.has(options.path)) {\n      throw new Error(`Duplicated api path: ${options.path}`);\n    }\n    const pathSpec = parsePathWithSlug(options.path);\n    if (options.render === 'static') {\n      apiPathMap.set(options.path, {\n        render: 'static',\n        pathSpec,\n        handlers: { GET: options.handler },\n      });\n    } else {\n      apiPathMap.set(options.path, {\n        render: 'dynamic',\n        pathSpec,\n        handlers: options.handlers,\n      });\n    }\n  };\n\n  const createRoot: CreateRoot = (root) => {\n    if (configured) {\n      throw new Error('createRoot no longer available');\n    }\n    if (rootItem) {\n      throw new Error(`Duplicated root component`);\n    }\n    if (root.render === 'static' || root.render === 'dynamic') {\n      rootItem = root;\n    } else {\n      throw new Error('Invalid root configuration');\n    }\n  };\n\n  const createPagePart: CreatePagePart = (params) => {\n    if (!import.meta.env.VITE_EXPERIMENTAL_WAKU_ROUTER) {\n      console.warn('createPagePart is still experimental');\n      return params;\n    }\n    if (params.path.endsWith('[path]')) {\n      throw new Error(\n        'Page part file cannot be named [path]. This will conflict with the path prop of the page component.',\n      );\n    }\n    if (configured) {\n      throw new Error('createPagePart no longer available');\n    }\n    const pagePartRenderMode = pagePartRenderModeMap.get(params.path);\n    if (!pagePartRenderMode) {\n      pagePartRenderModeMap.set(params.path, params.render);\n    } else if (params.render === 'dynamic' && pagePartRenderMode === 'static') {\n      pagePartRenderModeMap.set(params.path, 'dynamic');\n    }\n    const pathSpec = parsePathWithSlug(params.path);\n    const { numWildcards } = getSlugsAndWildcards(pathSpec);\n    const pagePathMap =\n      numWildcards === 0 ? dynamicPagePathMap : wildcardPagePathMap;\n    if (\n      pagePathMap.has(params.path) &&\n      !Array.isArray(pagePathMap.get(params.path)?.[1])\n    ) {\n      throw new Error(\n        `Duplicated path: ${params.path}. Tip: createPagePart cannot be used with createPage. Only one at a time is allowed.`,\n      );\n    }\n    if (params.render === 'static') {\n      const id =\n        joinPath(params.path, 'page').replace(/^\\//, '') + ':' + params.order;\n      registerStaticComponent(id, params.component);\n    }\n\n    if (!pagePathMap.has(params.path)) {\n      const pathComponents: ComponentList = [];\n      pathComponents[params.order] = {\n        component: params.component,\n        render: params.render,\n      };\n      pagePathMap.set(params.path, [pathSpec, pathComponents]);\n    } else {\n      const pageComponents = pagePathMap.get(params.path)?.[1];\n      if (Array.isArray(pageComponents)) {\n        if (pageComponents[params.order]) {\n          throw new Error(\n            'Duplicated pagePartComponent order: ' + params.order,\n          );\n        }\n        pageComponents[params.order] = {\n          render: params.render,\n          component: params.component,\n        };\n      }\n    }\n    return params as Exclude<\n      typeof params,\n      { path: never } | { render: never }\n    >;\n  };\n\n  let ready: Promise<AllPages | void> | undefined;\n  const configure = async () => {\n    if (!configured && !ready) {\n      ready = fn({\n        createPage,\n        createLayout,\n        createRoot,\n        createApi,\n        createPagePart,\n      });\n      await ready;\n\n      // check for page parts pages that can be made static\n      for (const [path, renderMode] of pagePartRenderModeMap) {\n        if (renderMode === 'dynamic') {\n          continue;\n        }\n        staticPagePartRoutes.add(path);\n        const pathSpec = parsePathWithSlug(path);\n        const { numWildcards } = getSlugsAndWildcards(pathSpec);\n        const pagePathMap =\n          numWildcards === 0 ? dynamicPagePathMap : wildcardPagePathMap;\n\n        pagePathMap.delete(path);\n        const pagePath = getGrouplessPath(path);\n        staticPathMap.set(pagePath, {\n          literalSpec: pathSpec,\n        });\n        if (path !== pagePath) {\n          groupPathLookup.set(pagePath, pagePath);\n        }\n      }\n\n      configured = true;\n    }\n    await ready;\n  };\n\n  const getLayouts = (spec: PathSpec): string[] => {\n    const pathSegments = spec.reduce<string[]>(\n      (acc, _segment, index) => {\n        acc.push(pathSpecAsString(spec.slice(0, index + 1)));\n        return acc;\n      },\n      ['/'],\n    );\n\n    return pathSegments.filter(\n      (segment) =>\n        dynamicLayoutPathMap.has(segment) ||\n        staticComponentMap.has(joinPath(segment, 'layout').slice(1)), // feels like a hack\n    );\n  };\n\n  const definedRouter = unstable_defineRouter({\n    getRouteConfig: async () => {\n      await configure();\n      const paths: {\n        path: PathSpec;\n        pathPattern?: PathSpec;\n        rootElement: { isStatic?: boolean };\n        routeElement: { isStatic?: boolean };\n        elements: Record<string, { isStatic?: boolean }>;\n        noSsr: boolean;\n      }[] = [];\n      const rootIsStatic = !rootItem || rootItem.render === 'static';\n      for (const [path, { literalSpec, originalSpec }] of staticPathMap) {\n        const noSsr = noSsrSet.has(literalSpec);\n\n        const layoutPaths = getLayouts(originalSpec ?? literalSpec);\n\n        const elements = {\n          ...layoutPaths.reduce<Record<string, { isStatic: boolean }>>(\n            (acc, lPath) => {\n              acc[`layout:${lPath}`] = {\n                isStatic: !dynamicLayoutPathMap.has(lPath),\n              };\n              return acc;\n            },\n            {},\n          ),\n          [`page:${path}`]: { isStatic: staticPathMap.has(path) },\n        };\n\n        paths.push({\n          path: literalSpec.filter((part) => !part.name?.startsWith('(')),\n          ...(originalSpec && { pathPattern: originalSpec }),\n          rootElement: { isStatic: rootIsStatic },\n          routeElement: {\n            isStatic: true,\n          },\n          elements,\n          noSsr,\n        });\n      }\n      for (const [path, [pathSpec, components]] of dynamicPagePathMap) {\n        const noSsr = noSsrSet.has(pathSpec);\n        const layoutPaths = getLayouts(pathSpec);\n        const elements = {\n          ...layoutPaths.reduce<Record<string, { isStatic: boolean }>>(\n            (acc, lPath) => {\n              acc[`layout:${lPath}`] = {\n                isStatic: !dynamicLayoutPathMap.has(lPath),\n              };\n              return acc;\n            },\n            {},\n          ),\n        };\n        if (Array.isArray(components)) {\n          for (let i = 0; i < components.length; i++) {\n            const component = components[i];\n            if (component) {\n              elements[`page:${path}:${i}`] = {\n                isStatic: component.render === 'static',\n              };\n            }\n          }\n        } else {\n          elements[`page:${path}`] = { isStatic: false };\n        }\n        paths.push({\n          path: pathSpec.filter((part) => !part.name?.startsWith('(')),\n          rootElement: { isStatic: rootIsStatic },\n          routeElement: { isStatic: true },\n          elements,\n          noSsr,\n        });\n      }\n      for (const [path, [pathSpec, components]] of wildcardPagePathMap) {\n        const noSsr = noSsrSet.has(pathSpec);\n        const layoutPaths = getLayouts(pathSpec);\n        const elements = {\n          ...layoutPaths.reduce<Record<string, { isStatic: boolean }>>(\n            (acc, lPath) => {\n              acc[`layout:${lPath}`] = {\n                isStatic: !dynamicLayoutPathMap.has(lPath),\n              };\n              return acc;\n            },\n            {},\n          ),\n        };\n        if (Array.isArray(components)) {\n          for (let i = 0; i < components.length; i++) {\n            const component = components[i];\n            if (component) {\n              elements[`page:${path}:${i}`] = {\n                isStatic: component.render === 'static',\n              };\n            }\n          }\n        } else {\n          elements[`page:${path}`] = { isStatic: false };\n        }\n        paths.push({\n          path: pathSpec.filter((part) => !part.name?.startsWith('(')),\n          rootElement: { isStatic: rootIsStatic },\n          routeElement: { isStatic: true },\n          elements,\n          noSsr,\n        });\n      }\n      return paths;\n    },\n    handleRoute: async (path, { query }) => {\n      await configure();\n\n      // path without slugs\n      const routePath = getPageRoutePath(path);\n      if (!routePath) {\n        throw new Error('Route not found: ' + path);\n      }\n\n      let pageComponent =\n        staticComponentMap.get(joinPath(routePath, 'page').slice(1)) ??\n        dynamicPagePathMap.get(routePath)?.[1] ??\n        wildcardPagePathMap.get(routePath)?.[1];\n      if (!pageComponent && staticPagePartRoutes.has(routePath)) {\n        pageComponent = [];\n        for (const [name, v] of staticComponentMap.entries()) {\n          if (name.startsWith(joinPath(routePath, 'page').slice(1))) {\n            pageComponent.push({\n              component: v,\n              render: 'static',\n            });\n          }\n        }\n      }\n      if (!pageComponent) {\n        throw new Error('Page not found: ' + path);\n      }\n      const layoutMatchPath = groupPathLookup.get(routePath) ?? routePath;\n      const pathSpec = parsePathWithSlug(layoutMatchPath);\n      const mapping = getPathMapping(pathSpec, path);\n      const result: Record<string, unknown> = {};\n      if (Array.isArray(pageComponent)) {\n        for (let i = 0; i < pageComponent.length; i++) {\n          const comp = pageComponent[i];\n          if (!comp) {\n            continue;\n          }\n          result[`page:${routePath}:${i}`] = createElement(comp.component, {\n            ...mapping,\n            ...(query ? { query } : {}),\n            path,\n          });\n        }\n      } else {\n        result[`page:${routePath}`] = createElement(\n          pageComponent,\n          { ...mapping, ...(query ? { query } : {}), path },\n          createElement(Children),\n        );\n      }\n\n      const layoutPaths = getLayouts(\n        getOriginalStaticPathSpec(path) ?? pathSpec,\n      );\n\n      for (const segment of layoutPaths) {\n        const layout =\n          dynamicLayoutPathMap.get(segment)?.[1] ??\n          staticComponentMap.get(joinPath(segment, 'layout').slice(1)); // feels like a hack\n\n        const isDynamic = dynamicLayoutPathMap.has(segment);\n\n        if (layout && !Array.isArray(layout)) {\n          const id = 'layout:' + segment;\n          result[id] = createElement(\n            layout,\n            isDynamic ? { path } : null,\n            createElement(Children),\n          );\n        } else {\n          throw new Error('Invalid layout ' + segment);\n        }\n      }\n      // loop over all layouts for path\n      const layouts = layoutPaths.map((lPath) => ({\n        component: Slot,\n        props: { id: `layout:${lPath}` },\n      }));\n      const finalPageChildren = Array.isArray(pageComponent)\n        ? createElement(\n            Fragment,\n            null,\n            pageComponent.map((_comp, order) =>\n              createElement(Slot, {\n                id: `page:${routePath}:${order}`,\n                key: `page:${routePath}:${order}`,\n              }),\n            ),\n          )\n        : createElement(Slot, { id: `page:${routePath}` });\n\n      return {\n        elements: result,\n        rootElement: createElement(\n          rootItem ? rootItem.component : DefaultRoot,\n          null,\n          createElement(Children),\n        ),\n        routeElement: createNestedElements(layouts, finalPageChildren),\n      };\n    },\n    getApiConfig: async () => {\n      await configure();\n\n      return Array.from(apiPathMap.values()).map(({ pathSpec, render }) => {\n        return {\n          path: pathSpec,\n          isStatic: render === 'static',\n        };\n      });\n    },\n    handleApi: async (path, { url, ...options }) => {\n      await configure();\n      const routePath = getApiRoutePath(path, options.method);\n      if (!routePath) {\n        throw new Error('API Route not found: ' + path);\n      }\n      const { handlers } = apiPathMap.get(routePath)!;\n      const req = new Request(url, options);\n      const handler = handlers[options.method as Method] ?? handlers.all;\n      if (!handler) {\n        throw new Error(\n          'API method not found: ' + options.method + 'for path: ' + path,\n        );\n      }\n      const res = await handler(req);\n\n      return {\n        ...(res.body ? { body: res.body } : {}),\n        headers: Object.fromEntries(res.headers.entries()),\n        status: res.status,\n      };\n    },\n  });\n\n  return definedRouter as typeof definedRouter & {\n    /** This for type inference of the router only. We do not actually return anything for this type. */\n    DO_NOT_USE_pages: Exclude<\n      Exclude<Awaited<Exclude<typeof ready, undefined>>, void>[number],\n      void // createLayout returns void\n    >;\n  };\n};\n\nconst getSlugsAndWildcards = (pathSpec: PathSpec) => {\n  let numSlugs = 0;\n  let numWildcards = 0;\n  for (const slug of pathSpec) {\n    if (slug.type !== 'literal') {\n      numSlugs++;\n    }\n    if (slug.type === 'wildcard') {\n      numWildcards++;\n    }\n  }\n  return { numSlugs, numWildcards };\n};\n"],"names":["createElement","Fragment","unstable_defineRouter","joinPath","parsePathWithSlug","getPathMapping","pathSpecAsString","parseExactPath","getGrouplessPath","Children","Slot","ErrorBoundary","METHODS","sanitizeSlug","slug","replace","DefaultRoot","children","createNestedElements","elements","reduceRight","result","element","component","props","createPages","fn","configured","groupPathLookup","Map","staticPathMap","pagePartRenderModeMap","staticPagePartRoutes","Set","dynamicPagePathMap","wildcardPagePathMap","dynamicLayoutPathMap","apiPathMap","staticComponentMap","rootItem","undefined","noSsrSet","WeakSet","getPageRoutePath","path","has","slice","allPaths","keys","p","getApiRoutePath","method","v","entries","handlers","all","pagePathExists","pathKey","_m","split","getOriginalStaticPathSpec","staticPathSpec","get","originalSpec","literalSpec","registerStaticComponent","id","Error","set","createPage","page","pathSpec","numSlugs","numWildcards","getSlugsAndWildcards","unstable_disableSSR","add","exactPath","spec","render","pagePath","staticPaths","map","item","Array","isArray","staticPath","length","mapping","slugIndex","pathItems","forEach","type","name","push","definedPath","join","WrappedComponent","createLayout","layout","createApi","options","GET","handler","createRoot","root","createPagePart","params","env","VITE_EXPERIMENTAL_WAKU_ROUTER","console","warn","endsWith","pagePartRenderMode","pagePathMap","order","pathComponents","pageComponents","ready","configure","renderMode","delete","getLayouts","pathSegments","reduce","acc","_segment","index","filter","segment","definedRouter","getRouteConfig","paths","rootIsStatic","noSsr","layoutPaths","lPath","isStatic","part","startsWith","pathPattern","rootElement","routeElement","components","i","handleRoute","query","routePath","pageComponent","layoutMatchPath","comp","isDynamic","layouts","finalPageChildren","_comp","key","getApiConfig","from","values","handleApi","url","req","Request","res","body","headers","Object","fromEntries","status"],"mappings":"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"}
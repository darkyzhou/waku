{"version":3,"sources":["../../src/router/fs-router.ts"],"sourcesContent":["import {\n  unstable_getPlatformData,\n  unstable_setPlatformData,\n  unstable_getBuildOptions,\n} from '../server.js';\nimport { createPages, METHODS } from './create-pages.js';\nimport type { Method } from './create-pages.js';\n\nimport { EXTENSIONS } from '../lib/builder/constants.js';\nimport { isIgnoredPath } from '../lib/utils/fs-router.js';\n\nconst DO_NOT_BUNDLE = '';\n\nexport function unstable_fsRouter(\n  importMetaUrl: string,\n  loadPage: (file: string) => Promise<any> | undefined,\n  options: {\n    /** e.g. `\"pages\"` will detect pages in `src/pages`. */\n    pagesDir: string;\n    /**\n     * e.g. `\"api\"` will detect pages in `src/pages/api`. Or, if `options.pagesDir`\n     * is `\"foo\"`, then it will detect pages in `src/foo/api`.\n     */\n    apiDir: string;\n  },\n) {\n  const buildOptions = unstable_getBuildOptions();\n  return createPages(\n    async ({ createPage, createLayout, createRoot, createApi }) => {\n      let files = await unstable_getPlatformData<string[]>('fsRouterFiles');\n      if (!files) {\n        // dev and build only\n        if (\n          import.meta.env &&\n          import.meta.env.MODE === 'production' &&\n          !buildOptions.unstable_phase\n        ) {\n          throw new Error('files must be set in production.');\n        }\n        const [\n          { readdir },\n          { join, dirname, extname, sep },\n          { fileURLToPath },\n        ] = await Promise.all([\n          import(/* @vite-ignore */ DO_NOT_BUNDLE + 'node:fs/promises'),\n          import(/* @vite-ignore */ DO_NOT_BUNDLE + 'node:path'),\n          import(/* @vite-ignore */ DO_NOT_BUNDLE + 'node:url'),\n        ]);\n        const pagesDir = join(\n          dirname(fileURLToPath(importMetaUrl)),\n          options.pagesDir,\n        );\n        files = await readdir(pagesDir, {\n          encoding: 'utf8',\n          recursive: true,\n        });\n        files = files!.flatMap((file) => {\n          const myExt = extname(file);\n          const myExtIndex = EXTENSIONS.indexOf(myExt);\n          if (myExtIndex === -1) {\n            return [];\n          }\n          // HACK: replace \"_slug_\" to \"[slug]\" for build\n          file = file.replace(/(?<=^|\\/|\\\\)_([^/]+)_(?=\\/|\\\\|\\.)/g, '[$1]');\n          // For Windows\n          file = sep === '/' ? file : file.replace(/\\\\/g, '/');\n          // HACK: resolve different extensions for build\n          const exts = [myExt, ...EXTENSIONS];\n          exts.splice(myExtIndex + 1, 1); // remove the second myExt\n          for (const ext of exts) {\n            const f = file.slice(0, -myExt.length) + ext;\n            if (loadPage(f)) {\n              return [f];\n            }\n          }\n          throw new Error('Failed to resolve ' + file);\n        });\n      }\n      // build only - skip in dev\n      if (buildOptions.unstable_phase) {\n        await unstable_setPlatformData('fsRouterFiles', files, true);\n      }\n      for (const file of files) {\n        const mod = await loadPage(file);\n        const config = await mod.getConfig?.();\n        const pathItems = file\n          .replace(/\\.\\w+$/, '')\n          .split('/')\n          .filter(Boolean);\n        if (isIgnoredPath(pathItems)) {\n          continue;\n        }\n        const path =\n          '/' +\n          (['_layout', 'index', '_root'].includes(pathItems.at(-1)!)\n            ? pathItems.slice(0, -1)\n            : pathItems\n          ).join('/');\n        if (pathItems.at(-1) === '[path]') {\n          throw new Error(\n            'Page file cannot be named [path]. This will conflict with the path prop of the page component.',\n          );\n        } else if (pathItems.at(0) === options.apiDir) {\n          if (config?.render === 'static') {\n            if (Object.keys(mod).length !== 2 || !mod.GET) {\n              console.warn(\n                `API ${path} is invalid. For static API routes, only a single GET handler is supported.`,\n              );\n            }\n            createApi({\n              path: pathItems.join('/'),\n              render: 'static',\n              method: 'GET',\n              handler: mod.GET,\n            });\n          } else {\n            const validMethods = new Set(METHODS);\n            const handlers = Object.fromEntries(\n              Object.entries(mod).filter(([exportName]) => {\n                const isValidExport =\n                  exportName === 'getConfig' ||\n                  validMethods.has(exportName as Method);\n                if (!isValidExport) {\n                  console.warn(\n                    `API ${path} has an invalid export: ${exportName}. Valid exports are: ${METHODS.join(\n                      ', ',\n                    )}`,\n                  );\n                }\n                return isValidExport && exportName !== 'getConfig';\n              }),\n            );\n            createApi({\n              path: pathItems.join('/'),\n              render: 'dynamic',\n              handlers,\n            });\n          }\n        } else if (pathItems.at(-1) === '_layout') {\n          createLayout({\n            path,\n            component: mod.default,\n            render: 'static',\n            ...config,\n          });\n        } else if (pathItems.at(-1) === '_root') {\n          createRoot({\n            component: mod.default,\n            render: 'static',\n            ...config,\n          });\n        } else {\n          createPage({\n            path,\n            component: mod.default,\n            render: 'dynamic',\n            ...config,\n          });\n        }\n      }\n      // HACK: to satisfy the return type, unused at runtime\n      return null as never;\n    },\n  );\n}\n"],"names":["unstable_getPlatformData","unstable_setPlatformData","unstable_getBuildOptions","createPages","METHODS","EXTENSIONS","isIgnoredPath","DO_NOT_BUNDLE","unstable_fsRouter","importMetaUrl","loadPage","options","buildOptions","createPage","createLayout","createRoot","createApi","files","env","MODE","unstable_phase","Error","readdir","join","dirname","extname","sep","fileURLToPath","Promise","all","pagesDir","encoding","recursive","flatMap","file","myExt","myExtIndex","indexOf","replace","exts","splice","ext","f","slice","length","mod","config","getConfig","pathItems","split","filter","Boolean","path","includes","at","apiDir","render","Object","keys","GET","console","warn","method","handler","validMethods","Set","handlers","fromEntries","entries","exportName","isValidExport","has","component","default"],"mappings":"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"}
{"version":3,"sources":["../../../src/lib/plugins/vite-plugin-deploy-txiki.ts"],"sourcesContent":["import type { Plugin } from 'vite';\nimport {\n  unstable_getBuildOptions,\n  unstable_builderConstants,\n} from '../../server.js';\n\nconst { SRC_ENTRIES, DIST_PUBLIC } = unstable_builderConstants;\n\nconst SERVE_JS = 'serve-txiki.js';\n\nconst getServeJsContent = (\n  distDir: string,\n  distPublic: string,\n  srcEntriesFile: string,\n) => `\nimport getopts from \"tjs:getopts\";\n\nconst { serverEngine, importHono, importHonoServeStatic } = await import('waku/unstable_hono');\nconst { Hono } = await importHono();\nconst { serveStatic: baseServeStatic } = await importHonoServeStatic();\n\nconst distDir = '${distDir}';\nconst publicDir = '${distPublic}';\nconst loadEntries = () => import('${srcEntriesFile}');\nconst configPromise = loadEntries().then((entries) => entries.loadConfig());\nconst env = tjs.env;\n\nconst serveStatic = (c, next) => {\n  const isDir = async (path) => {\n    try {\n      const stat = await tjs.stat(path);\n      return stat.isDirectory;\n    } catch {\n      return undefined;\n    }\n  };\n  const getContent = async (path) => {\n    try {\n      if (await isDir(path)) {\n        return null;\n      }\n      const handle = await tjs.open(path, \"r\");\n      return handle.readable;\n    } catch {\n      return null;\n    }\n  };\n  const pathResolve = (path) => {\n    return path.startsWith('/') ? path : './' + path;\n  };\n  return baseServeStatic({\n    isDir,\n    getContent,\n    pathResolve,\n    root: distDir + '/' + publicDir\n  })(c, next);\n}\n\nconst createApp = (app) => {\n  app.use(serveStatic);\n  app.use(serverEngine({ cmd: 'start', loadEntries, env, unstable_onError: new Set() }));\n  app.notFound(async (c) => {\n    const file = distDir + '/' + publicDir + '/404.html';\n    try {\n      const info = await tjs.stat(file);\n      if (info.isFile) {\n        c.header('Content-Type', 'text/html; charset=utf-8');\n        return c.body(await tjs.readFile(file), 404);\n      }\n    } catch {}\n    return c.text('404 Not Found', 404);\n  });\n  return app;\n};\n\nconst HONO_ENHANCER = (await configPromise).unstable_honoEnhancer || ((createApp) => createApp);\nconst HONO_APP = HONO_ENHANCER(createApp)(new Hono());\n\nconst ENCODER = new TextEncoder();\nconst ENCODED_NEWLINE = ENCODER.encode(\"\\\\r\\\\n\");\nconst ENCODED_CHUNK_END = ENCODER.encode(\"0\\\\r\\\\n\\\\r\\\\n\");\n\nconst parseRequestPayload = (request) => {\n  if (!request || !request.includes('\\\\r\\\\n\\\\r\\\\n')) {\n    return;\n  }\n\n  const [requestLineAndHeaders, body] = request.split(\"\\r\\n\\r\\n\");\n  const theBody = !body ? undefined : body;\n  try {\n    const [requestLine, ...requestLines] = requestLineAndHeaders.split(\"\\\\r\\\\n\");\n    const [method, path, protocol] = requestLine.split(\" \");\n    const headers = Object.fromEntries(requestLines.map(line => line.split(': ', 2)).filter(([key]) => key));\n    return { method, path, protocol, headers, body: theBody };\n  } catch (e) {\n    console.error(\\`parseRequestPayload error: \\${e}, request: \\${request}\\`);\n    return null;\n  }\n}\n\nconst handleConnection = async (listener, connection) => {\n  let len = 0;\n  const buf = new Uint8Array(65536);\n  const nread = await connection.read(buf);\n  len += (nread || 0);\n  \n  const requestString = new TextDecoder().decode(buf.subarray(0, len));\n  const parseResult = parseRequestPayload(requestString);\n  if (!parseResult) {\n    return;\n  }\n\n  const { method, path, protocol, headers, body } = parseResult;\n  const url = \\`http://localhost:\\${listener.localAddress.port}\\${path}\\`;\n  const request = new Request(url, { method, path, protocol, headers, body });\n\n  const response = await HONO_APP.fetch(request);\n  let responseHeaders = \"\";\n  for (const [key, value] of response.headers.entries()) {\n    responseHeaders += \\`\\${key}: \\${value}\\\\r\\\\n\\`;\n  }\n  const bodyType = typeof response._bodyInit === 'string' ? 'string' :\n    response._bodyInit instanceof ReadableStream ? 'stream' : 'buffer';\n  if (bodyType === 'stream') {\n    responseHeaders += \\`transfer-encoding: chunked\\\\r\\\\n\\`;\n  }\n\n  connection.setNoDelay(true);\n  await connection.write(new TextEncoder().encode(\\`HTTP/1.1 \\${response.status} \\${response.statusText}\\\\r\\\\n\\${responseHeaders}\\\\r\\\\n\\`));\n  if (bodyType === 'string') {\n    await connection.write(ENCODER.encode(await response.text()));\n  } else if (bodyType === 'buffer') {\n    const data = await response.arrayBuffer();\n    await connection.write(new Uint8Array(data));\n  } else {\n    const chunkedEncoder = new TransformStream({\n      transform(chunk, controller) {\n        controller.enqueue(ENCODER.encode(chunk.length.toString(16)));\n        controller.enqueue(ENCODED_NEWLINE);\n        controller.enqueue(chunk);\n        controller.enqueue(ENCODED_NEWLINE);\n      },\n      flush(controller) {\n        controller.enqueue(ENCODED_CHUNK_END);\n      }\n    });\n    const theBody = response._bodyInit;\n    await theBody.pipeThrough(chunkedEncoder).pipeTo(connection.writable);\n  }\n\n  connection.close();\n}\n\nconst options = getopts(tjs.args.slice(2), {\n  alias: { listen: \"l\", port: \"p\" },\n  default: { listen: \"127.0.0.1\", port: 8080 },\n});\nconst listener = await tjs.listen(\"tcp\", options.listen, options.port);\n\nconsole.log(\\`Listening on \\${listener.localAddress.ip}:\\${listener.localAddress.port}\\`);\nfor await (let connection of listener) {\n  handleConnection(listener, connection).catch((e) => {\n    console.error('handleConnection error', e);\n  });\n  connection = undefined;\n}\n`.trim();\n\nexport function deployTxikiPlugin(opts: {\n  srcDir: string;\n  distDir: string;\n}): Plugin {\n  const buildOptions = unstable_getBuildOptions();\n  let entriesFile: string;\n  return {\n    name: 'deploy-txiki-plugin',\n    config(viteConfig) {\n      const { deploy, unstable_phase } = buildOptions;\n      if (unstable_phase !== 'buildServerBundle' || deploy !== 'txiki') {\n        return;\n      }\n\n      const { input } = viteConfig.build?.rollupOptions ?? {};\n      if (input && !(typeof input === 'string') && !(input instanceof Array)) {\n        input[SERVE_JS.replace(/\\.js$/, '')] = `${opts.srcDir}/${SERVE_JS}`;\n      }\n    },\n    configResolved(config) {\n      entriesFile = `${config.root}/${opts.srcDir}/${SRC_ENTRIES}`;\n\n      const { deploy, unstable_phase } = buildOptions;\n      if (\n        (unstable_phase !== 'buildServerBundle' &&\n          unstable_phase !== 'buildSsrBundle') ||\n        deploy !== 'txiki'\n      ) {\n        return;\n      }\n      config.ssr.target = 'webworker';\n      config.ssr.resolve ||= {};\n      config.ssr.resolve.conditions ||= [];\n      config.ssr.resolve.conditions.push('worker');\n      config.ssr.resolve.externalConditions ||= [];\n      config.ssr.resolve.externalConditions.push('worker');\n\n      if (Array.isArray(config.build.rollupOptions.output)) {\n        throw new Error('vite-plugin-deploy-txiki: unexpected array output');\n      }\n\n      if (!config.build?.rollupOptions?.output) {\n        config.build.rollupOptions.output = {};\n      }\n      config.build.rollupOptions.output.manualChunks = (id: string) => {\n        if (id.includes('/lib/config.js')) {\n          return 'config';\n        }\n      };\n    },\n    resolveId(source) {\n      if (source === `${opts.srcDir}/${SERVE_JS}`) {\n        return source;\n      }\n\n      if (source.startsWith('tjs:')) {\n        return { id: source, external: true };\n      }\n    },\n    load(id) {\n      if (id === `${opts.srcDir}/${SERVE_JS}`) {\n        return getServeJsContent(opts.distDir, DIST_PUBLIC, entriesFile);\n      }\n    },\n  };\n}\n"],"names":["unstable_getBuildOptions","unstable_builderConstants","SRC_ENTRIES","DIST_PUBLIC","SERVE_JS","getServeJsContent","distDir","distPublic","srcEntriesFile","trim","deployTxikiPlugin","opts","buildOptions","entriesFile","name","config","viteConfig","deploy","unstable_phase","input","build","rollupOptions","Array","replace","srcDir","configResolved","root","ssr","target","resolve","conditions","push","externalConditions","isArray","output","Error","manualChunks","id","includes","resolveId","source","startsWith","external","load"],"mappings":"AACA,SACEA,wBAAwB,EACxBC,yBAAyB,QACpB,kBAAkB;AAEzB,MAAM,EAAEC,WAAW,EAAEC,WAAW,EAAE,GAAGF;AAErC,MAAMG,WAAW;AAEjB,MAAMC,oBAAoB,CACxBC,SACAC,YACAC,iBACG,CAAC;;;;;;;iBAOW,EAAEF,QAAQ;mBACR,EAAEC,WAAW;kCACE,EAAEC,eAAe;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+InD,CAAC,CAACC,IAAI;AAEN,OAAO,SAASC,kBAAkBC,IAGjC;IACC,MAAMC,eAAeZ;IACrB,IAAIa;IACJ,OAAO;QACLC,MAAM;QACNC,QAAOC,UAAU;YACf,MAAM,EAAEC,MAAM,EAAEC,cAAc,EAAE,GAAGN;YACnC,IAAIM,mBAAmB,uBAAuBD,WAAW,SAAS;gBAChE;YACF;YAEA,MAAM,EAAEE,KAAK,EAAE,GAAGH,WAAWI,KAAK,EAAEC,iBAAiB,CAAC;YACtD,IAAIF,SAAS,CAAE,CAAA,OAAOA,UAAU,QAAO,KAAM,CAAEA,CAAAA,iBAAiBG,KAAI,GAAI;gBACtEH,KAAK,CAACf,SAASmB,OAAO,CAAC,SAAS,IAAI,GAAG,GAAGZ,KAAKa,MAAM,CAAC,CAAC,EAAEpB,UAAU;YACrE;QACF;QACAqB,gBAAeV,MAAM;YACnBF,cAAc,GAAGE,OAAOW,IAAI,CAAC,CAAC,EAAEf,KAAKa,MAAM,CAAC,CAAC,EAAEtB,aAAa;YAE5D,MAAM,EAAEe,MAAM,EAAEC,cAAc,EAAE,GAAGN;YACnC,IACE,AAACM,mBAAmB,uBAClBA,mBAAmB,oBACrBD,WAAW,SACX;gBACA;YACF;YACAF,OAAOY,GAAG,CAACC,MAAM,GAAG;YACpBb,OAAOY,GAAG,CAACE,OAAO,KAAK,CAAC;YACxBd,OAAOY,GAAG,CAACE,OAAO,CAACC,UAAU,KAAK,EAAE;YACpCf,OAAOY,GAAG,CAACE,OAAO,CAACC,UAAU,CAACC,IAAI,CAAC;YACnChB,OAAOY,GAAG,CAACE,OAAO,CAACG,kBAAkB,KAAK,EAAE;YAC5CjB,OAAOY,GAAG,CAACE,OAAO,CAACG,kBAAkB,CAACD,IAAI,CAAC;YAE3C,IAAIT,MAAMW,OAAO,CAAClB,OAAOK,KAAK,CAACC,aAAa,CAACa,MAAM,GAAG;gBACpD,MAAM,IAAIC,MAAM;YAClB;YAEA,IAAI,CAACpB,OAAOK,KAAK,EAAEC,eAAea,QAAQ;gBACxCnB,OAAOK,KAAK,CAACC,aAAa,CAACa,MAAM,GAAG,CAAC;YACvC;YACAnB,OAAOK,KAAK,CAACC,aAAa,CAACa,MAAM,CAACE,YAAY,GAAG,CAACC;gBAChD,IAAIA,GAAGC,QAAQ,CAAC,mBAAmB;oBACjC,OAAO;gBACT;YACF;QACF;QACAC,WAAUC,MAAM;YACd,IAAIA,WAAW,GAAG7B,KAAKa,MAAM,CAAC,CAAC,EAAEpB,UAAU,EAAE;gBAC3C,OAAOoC;YACT;YAEA,IAAIA,OAAOC,UAAU,CAAC,SAAS;gBAC7B,OAAO;oBAAEJ,IAAIG;oBAAQE,UAAU;gBAAK;YACtC;QACF;QACAC,MAAKN,EAAE;YACL,IAAIA,OAAO,GAAG1B,KAAKa,MAAM,CAAC,CAAC,EAAEpB,UAAU,EAAE;gBACvC,OAAOC,kBAAkBM,KAAKL,OAAO,EAAEH,aAAaU;YACtD;QACF;IACF;AACF"}
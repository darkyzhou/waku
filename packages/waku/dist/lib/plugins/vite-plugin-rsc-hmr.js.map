{"version":3,"sources":["../../../src/lib/plugins/vite-plugin-rsc-hmr.ts"],"sourcesContent":["import type {\n  HMRBroadcaster,\n  HtmlTagDescriptor,\n  Plugin,\n  TransformResult,\n  ViteDevServer,\n} from 'vite';\n\nimport {\n  joinPath,\n  fileURLToFilePath,\n  decodeFilePathFromAbsolute,\n  filePathToFileURL,\n} from '../utils/path.js';\n\ntype ModuleImportResult = TransformResult & {\n  id: string;\n  // non-transformed result of `TransformResult.code`\n  source: string;\n  css?: boolean;\n};\n\nconst injectingHmrCode = `\nimport { createHotContext as __vite__createHotContext } from \"/@vite/client\";\nimport.meta.hot = __vite__createHotContext(import.meta.url);\n\nif (import.meta.hot && !globalThis.__WAKU_HMR_CONFIGURED__) {\n  globalThis.__WAKU_HMR_CONFIGURED__ = true;\n  import.meta.hot.on('vite:afterUpdate', (data) => {\n    if (data.type === 'update') {\n      for (const update of data.updates) {\n        if (\n          update.type === 'js-update' &&\n          globalThis.__WAKU_CLIENT_MODULE_LOADING__.has(update.path)\n        ) {\n          globalThis.__WAKU_CLIENT_MODULE_LOADING__.set(update.path,\n            globalThis.__WAKU_CLIENT_IMPORT__(update.path + '?t=' + update.timestamp).then((m) => {\n              globalThis.__WAKU_CLIENT_MODULE_CACHE__.set(update.path, m);\n            })\n          );\n        }\n      }\n    }\n  });\n  import.meta.hot.on('rsc-reload', () => {\n    globalThis.__WAKU_RSC_RELOAD_LISTENERS__?.forEach((l) => l());\n  });\n  import.meta.hot.on('hot-import', (data) => import(/* @vite-ignore */ data));\n  import.meta.hot.on('module-import', (data) => {\n    // remove element with the same 'waku-module-id'\n    let script = document.querySelector('script[waku-module-id=\"' + data.id + '\"]');\n    let style = document.querySelector('style[waku-module-id=\"' + data.id + '\"]');\n    script?.remove();\n    const code = data.code;\n    script = document.createElement('script');\n    script.type = 'module';\n    script.text = code;\n    script.setAttribute('waku-module-id', data.id);\n    document.head.appendChild(script);\n    // avoid HMR flash by first applying the new and removing the old styles \n    if (style) {\n      queueMicrotask(() => style.parentElement?.removeChild(style));\n    }\n  });\n  import.meta.hot.on('vite:invalidate', () => {\n    // FIXME is there a better solution?\n    location.reload();\n  });\n}\n`;\n\nexport function rscHmrPlugin(): Plugin {\n  const wakuMinimalClientDist = decodeFilePathFromAbsolute(\n    joinPath(fileURLToFilePath(import.meta.url), '../../../minimal/client.js'),\n  );\n  const wakuRouterClientDist = decodeFilePathFromAbsolute(\n    joinPath(fileURLToFilePath(import.meta.url), '../../../router/client.js'),\n  );\n  let viteServer: ViteDevServer;\n  return {\n    name: 'rsc-hmr-plugin',\n    enforce: 'post',\n    configureServer(server) {\n      viteServer = server;\n    },\n    async transformIndexHtml() {\n      return [\n        ...(await generateInitialScripts(viteServer)),\n        {\n          tag: 'script',\n          attrs: { type: 'module', async: true },\n          children: injectingHmrCode,\n          injectTo: 'head',\n        },\n      ];\n    },\n    async transform(code, id) {\n      if (id.startsWith(wakuMinimalClientDist)) {\n        // FIXME this is fragile. Can we do it better?\n        return code.replace(\n          /\\nexport const fetchRsc = \\(.*?\\)=>\\{/,\n          (m) =>\n            m +\n            `\n{\n  const refetchRsc = () => {\n    delete fetchCache[ENTRY];\n    const data = fetchRsc(rscPath, rscParams, fetchCache);\n    fetchCache[SET_ELEMENTS](() => data);\n  };\n  globalThis.__WAKU_RSC_RELOAD_LISTENERS__ ||= [];\n  const index = globalThis.__WAKU_RSC_RELOAD_LISTENERS__.indexOf(globalThis.__WAKU_REFETCH_RSC__);\n  if (index !== -1) {\n    globalThis.__WAKU_RSC_RELOAD_LISTENERS__.splice(index, 1, refetchRsc);\n  } else {\n    globalThis.__WAKU_RSC_RELOAD_LISTENERS__.push(refetchRsc);\n  }\n  globalThis.__WAKU_REFETCH_RSC__ = refetchRsc;\n}\n`,\n        );\n      } else if (id.startsWith(wakuRouterClientDist)) {\n        // FIXME this is fragile. Can we do it better?\n        return code.replace(\n          /\\nconst InnerRouter = \\(.*?\\)=>\\{/,\n          (m) =>\n            m +\n            `\n{\n  const refetchRoute = () => {\n    staticPathSet.clear();\n    routerData[2].clear(); // cacheIdSet\n    const rscPath = encodeRoutePath(route.path);\n    const rscParams = createRscParams(route.query, []);\n    refetch(rscPath, rscParams);\n  };\n  globalThis.__WAKU_RSC_RELOAD_LISTENERS__ ||= [];\n  const index = globalThis.__WAKU_RSC_RELOAD_LISTENERS__.indexOf(globalThis.__WAKU_REFETCH_ROUTE__);\n  if (index !== -1) {\n    globalThis.__WAKU_RSC_RELOAD_LISTENERS__.splice(index, 1, refetchRoute);\n  } else {\n    globalThis.__WAKU_RSC_RELOAD_LISTENERS__.unshift(refetchRoute);\n  }\n  globalThis.__WAKU_REFETCH_ROUTE__ = refetchRoute;\n}\n`,\n        );\n      }\n    },\n    handleHotUpdate({ file }) {\n      if (file.endsWith('/pages.gen.ts')) {\n        // auto generated file by fsRouterTypegenPlugin\n        return [];\n      }\n      const moduleLoading = (globalThis as any).__WAKU_CLIENT_MODULE_LOADING__;\n      const moduleCache = (globalThis as any).__WAKU_CLIENT_MODULE_CACHE__;\n      if (!moduleLoading || !moduleCache) {\n        return;\n      }\n      if (file.startsWith(viteServer.config.root + '/')) {\n        file = file.slice(viteServer.config.root.length + 1);\n      }\n      const id = filePathToFileURL(file);\n      if (moduleLoading.has(id)) {\n        moduleLoading.set(\n          id,\n          viteServer.ssrLoadModule(file).then((m) => {\n            // XXX There can be a race condition, but it should be very rare.\n            moduleCache.set(id, m);\n          }),\n        );\n      }\n    },\n  };\n}\n\nconst pendingMap = new WeakMap<ReturnType<typeof viteHot>, Set<string>>();\n\nfunction viteHot(viteServer: ViteDevServer): HMRBroadcaster {\n  return viteServer.hot ?? viteServer.ws;\n}\n\nfunction hotImport(viteServer: ViteDevServer, source: string) {\n  const hot = viteHot(viteServer);\n  let sourceSet = pendingMap.get(hot);\n  if (!sourceSet) {\n    sourceSet = new Set();\n    pendingMap.set(hot, sourceSet);\n    hot.on('connection', () => {\n      for (const source of sourceSet!) {\n        hot.send({\n          type: 'custom',\n          event: 'hot-import',\n          data: source,\n        });\n      }\n    });\n  }\n  sourceSet.add(source);\n  hot.send({ type: 'custom', event: 'hot-import', data: source });\n}\n\nconst modulePendingMap = new WeakMap<\n  ReturnType<typeof viteHot>,\n  Map<string, ModuleImportResult>\n>();\n\nfunction moduleImport(viteServer: ViteDevServer, result: ModuleImportResult) {\n  const hot = viteHot(viteServer);\n  let sources = modulePendingMap.get(hot);\n  if (!sources) {\n    sources = new Map();\n    modulePendingMap.set(hot, sources);\n  }\n  sources.set(result.id, result);\n  hot.send({ type: 'custom', event: 'module-import', data: result });\n}\n\nasync function generateInitialScripts(\n  viteServer: ViteDevServer,\n): Promise<HtmlTagDescriptor[]> {\n  const hot = viteHot(viteServer);\n  const sources = modulePendingMap.get(hot);\n\n  if (!sources) {\n    return [];\n  }\n\n  const scripts: HtmlTagDescriptor[] = [];\n\n  for (const result of sources.values()) {\n    scripts.push({\n      tag: 'script',\n      attrs: {\n        type: 'module',\n        async: true,\n        blocking: 'render',\n        'waku-module-id': result.id,\n      },\n      children: result.code,\n      injectTo: 'head',\n    });\n  }\n  return scripts;\n}\n\nexport type HotUpdatePayload =\n  | { type: 'full-reload' }\n  | { type: 'custom'; event: 'rsc-reload' }\n  | { type: 'custom'; event: 'hot-import'; data: string }\n  | { type: 'custom'; event: 'module-import'; data: ModuleImportResult };\n\nexport function hotUpdate(vite: ViteDevServer, payload: HotUpdatePayload) {\n  const hot = viteHot(vite);\n  if (payload.type === 'full-reload') {\n    hot.send(payload);\n  } else if (payload.event === 'rsc-reload') {\n    hot.send(payload);\n  } else if (payload.event === 'hot-import') {\n    hotImport(vite, payload.data);\n  } else if (payload.event === 'module-import') {\n    moduleImport(vite, payload.data);\n  }\n}\n"],"names":["joinPath","fileURLToFilePath","decodeFilePathFromAbsolute","filePathToFileURL","injectingHmrCode","rscHmrPlugin","wakuMinimalClientDist","url","wakuRouterClientDist","viteServer","name","enforce","configureServer","server","transformIndexHtml","generateInitialScripts","tag","attrs","type","async","children","injectTo","transform","code","id","startsWith","replace","m","handleHotUpdate","file","endsWith","moduleLoading","globalThis","__WAKU_CLIENT_MODULE_LOADING__","moduleCache","__WAKU_CLIENT_MODULE_CACHE__","config","root","slice","length","has","set","ssrLoadModule","then","pendingMap","WeakMap","viteHot","hot","ws","hotImport","source","sourceSet","get","Set","on","send","event","data","add","modulePendingMap","moduleImport","result","sources","Map","scripts","values","push","blocking","hotUpdate","vite","payload"],"mappings":"AAQA,SACEA,QAAQ,EACRC,iBAAiB,EACjBC,0BAA0B,EAC1BC,iBAAiB,QACZ,mBAAmB;AAS1B,MAAMC,mBAAmB,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+C1B,CAAC;AAED,OAAO,SAASC;IACd,MAAMC,wBAAwBJ,2BAC5BF,SAASC,kBAAkB,YAAYM,GAAG,GAAG;IAE/C,MAAMC,uBAAuBN,2BAC3BF,SAASC,kBAAkB,YAAYM,GAAG,GAAG;IAE/C,IAAIE;IACJ,OAAO;QACLC,MAAM;QACNC,SAAS;QACTC,iBAAgBC,MAAM;YACpBJ,aAAaI;QACf;QACA,MAAMC;YACJ,OAAO;mBACD,MAAMC,uBAAuBN;gBACjC;oBACEO,KAAK;oBACLC,OAAO;wBAAEC,MAAM;wBAAUC,OAAO;oBAAK;oBACrCC,UAAUhB;oBACViB,UAAU;gBACZ;aACD;QACH;QACA,MAAMC,WAAUC,IAAI,EAAEC,EAAE;YACtB,IAAIA,GAAGC,UAAU,CAACnB,wBAAwB;gBACxC,8CAA8C;gBAC9C,OAAOiB,KAAKG,OAAO,CACjB,yCACA,CAACC,IACCA,IACA,CAAC;;;;;;;;;;;;;;;;AAgBb,CAAC;YAEK,OAAO,IAAIH,GAAGC,UAAU,CAACjB,uBAAuB;gBAC9C,8CAA8C;gBAC9C,OAAOe,KAAKG,OAAO,CACjB,qCACA,CAACC,IACCA,IACA,CAAC;;;;;;;;;;;;;;;;;;AAkBb,CAAC;YAEK;QACF;QACAC,iBAAgB,EAAEC,IAAI,EAAE;YACtB,IAAIA,KAAKC,QAAQ,CAAC,kBAAkB;gBAClC,+CAA+C;gBAC/C,OAAO,EAAE;YACX;YACA,MAAMC,gBAAgB,AAACC,WAAmBC,8BAA8B;YACxE,MAAMC,cAAc,AAACF,WAAmBG,4BAA4B;YACpE,IAAI,CAACJ,iBAAiB,CAACG,aAAa;gBAClC;YACF;YACA,IAAIL,KAAKJ,UAAU,CAAChB,WAAW2B,MAAM,CAACC,IAAI,GAAG,MAAM;gBACjDR,OAAOA,KAAKS,KAAK,CAAC7B,WAAW2B,MAAM,CAACC,IAAI,CAACE,MAAM,GAAG;YACpD;YACA,MAAMf,KAAKrB,kBAAkB0B;YAC7B,IAAIE,cAAcS,GAAG,CAAChB,KAAK;gBACzBO,cAAcU,GAAG,CACfjB,IACAf,WAAWiC,aAAa,CAACb,MAAMc,IAAI,CAAC,CAAChB;oBACnC,iEAAiE;oBACjEO,YAAYO,GAAG,CAACjB,IAAIG;gBACtB;YAEJ;QACF;IACF;AACF;AAEA,MAAMiB,aAAa,IAAIC;AAEvB,SAASC,QAAQrC,UAAyB;IACxC,OAAOA,WAAWsC,GAAG,IAAItC,WAAWuC,EAAE;AACxC;AAEA,SAASC,UAAUxC,UAAyB,EAAEyC,MAAc;IAC1D,MAAMH,MAAMD,QAAQrC;IACpB,IAAI0C,YAAYP,WAAWQ,GAAG,CAACL;IAC/B,IAAI,CAACI,WAAW;QACdA,YAAY,IAAIE;QAChBT,WAAWH,GAAG,CAACM,KAAKI;QACpBJ,IAAIO,EAAE,CAAC,cAAc;YACnB,KAAK,MAAMJ,UAAUC,UAAY;gBAC/BJ,IAAIQ,IAAI,CAAC;oBACPrC,MAAM;oBACNsC,OAAO;oBACPC,MAAMP;gBACR;YACF;QACF;IACF;IACAC,UAAUO,GAAG,CAACR;IACdH,IAAIQ,IAAI,CAAC;QAAErC,MAAM;QAAUsC,OAAO;QAAcC,MAAMP;IAAO;AAC/D;AAEA,MAAMS,mBAAmB,IAAId;AAK7B,SAASe,aAAanD,UAAyB,EAAEoD,MAA0B;IACzE,MAAMd,MAAMD,QAAQrC;IACpB,IAAIqD,UAAUH,iBAAiBP,GAAG,CAACL;IACnC,IAAI,CAACe,SAAS;QACZA,UAAU,IAAIC;QACdJ,iBAAiBlB,GAAG,CAACM,KAAKe;IAC5B;IACAA,QAAQrB,GAAG,CAACoB,OAAOrC,EAAE,EAAEqC;IACvBd,IAAIQ,IAAI,CAAC;QAAErC,MAAM;QAAUsC,OAAO;QAAiBC,MAAMI;IAAO;AAClE;AAEA,eAAe9C,uBACbN,UAAyB;IAEzB,MAAMsC,MAAMD,QAAQrC;IACpB,MAAMqD,UAAUH,iBAAiBP,GAAG,CAACL;IAErC,IAAI,CAACe,SAAS;QACZ,OAAO,EAAE;IACX;IAEA,MAAME,UAA+B,EAAE;IAEvC,KAAK,MAAMH,UAAUC,QAAQG,MAAM,GAAI;QACrCD,QAAQE,IAAI,CAAC;YACXlD,KAAK;YACLC,OAAO;gBACLC,MAAM;gBACNC,OAAO;gBACPgD,UAAU;gBACV,kBAAkBN,OAAOrC,EAAE;YAC7B;YACAJ,UAAUyC,OAAOtC,IAAI;YACrBF,UAAU;QACZ;IACF;IACA,OAAO2C;AACT;AAQA,OAAO,SAASI,UAAUC,IAAmB,EAAEC,OAAyB;IACtE,MAAMvB,MAAMD,QAAQuB;IACpB,IAAIC,QAAQpD,IAAI,KAAK,eAAe;QAClC6B,IAAIQ,IAAI,CAACe;IACX,OAAO,IAAIA,QAAQd,KAAK,KAAK,cAAc;QACzCT,IAAIQ,IAAI,CAACe;IACX,OAAO,IAAIA,QAAQd,KAAK,KAAK,cAAc;QACzCP,UAAUoB,MAAMC,QAAQb,IAAI;IAC9B,OAAO,IAAIa,QAAQd,KAAK,KAAK,iBAAiB;QAC5CI,aAAaS,MAAMC,QAAQb,IAAI;IACjC;AACF"}
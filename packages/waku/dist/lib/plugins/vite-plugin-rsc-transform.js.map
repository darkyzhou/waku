{"version":3,"sources":["../../../src/lib/plugins/vite-plugin-rsc-transform.ts"],"sourcesContent":["import type { Plugin } from 'vite';\nimport * as swc from '@swc/core';\n\nimport { EXTENSIONS } from '../builder/constants.js';\nimport { extname, joinPath } from '../utils/path.js';\nimport { parseOpts } from '../utils/swc.js';\n\nconst collectExportNames = (mod: swc.Module) => {\n  const exportNames = new Set<string>();\n  for (const item of mod.body) {\n    if (item.type === 'ExportDeclaration') {\n      if (item.declaration.type === 'FunctionDeclaration') {\n        exportNames.add(item.declaration.identifier.value);\n      } else if (item.declaration.type === 'ClassDeclaration') {\n        exportNames.add(item.declaration.identifier.value);\n      } else if (item.declaration.type === 'VariableDeclaration') {\n        for (const d of item.declaration.declarations) {\n          if (d.id.type === 'Identifier') {\n            exportNames.add(d.id.value);\n          }\n        }\n      }\n    } else if (item.type === 'ExportNamedDeclaration') {\n      for (const s of item.specifiers) {\n        if (s.type === 'ExportSpecifier') {\n          exportNames.add(s.exported ? s.exported.value : s.orig.value);\n        }\n      }\n    } else if (item.type === 'ExportDefaultExpression') {\n      exportNames.add('default');\n    } else if (item.type === 'ExportDefaultDeclaration') {\n      exportNames.add('default');\n    }\n  }\n  return exportNames;\n};\n\nconst transformClient = (\n  code: string,\n  ext: string,\n  getServerId: () => string,\n) => {\n  if (!code.includes('use server')) {\n    return;\n  }\n  const mod = swc.parseSync(code, parseOpts(ext));\n  let hasUseServer = false;\n  for (const item of mod.body) {\n    if (item.type === 'ExpressionStatement') {\n      if (\n        item.expression.type === 'StringLiteral' &&\n        item.expression.value === 'use server'\n      ) {\n        hasUseServer = true;\n      }\n    } else {\n      break;\n    }\n  }\n  if (hasUseServer) {\n    const exportNames = collectExportNames(mod);\n    let newCode = `\nimport { createServerReference } from 'react-server-dom-webpack/client';\nimport { unstable_callServerRsc as callServerRsc } from 'waku/minimal/client';\n`;\n    for (const name of exportNames) {\n      newCode += `\nexport ${name === 'default' ? name : `const ${name} =`} createServerReference('${getServerId()}#${name}', callServerRsc);\n`;\n    }\n    return swc.transformSync(newCode, {\n      jsc: { parser: parseOpts(ext), target: 'esnext' },\n      sourceMaps: true,\n    });\n  }\n};\n\nconst transformClientForSSR = (code: string, ext: string) => {\n  if (!code.includes('use server')) {\n    return;\n  }\n  const mod = swc.parseSync(code, parseOpts(ext));\n  let hasUseServer = false;\n  for (const item of mod.body) {\n    if (item.type === 'ExpressionStatement') {\n      if (\n        item.expression.type === 'StringLiteral' &&\n        item.expression.value === 'use server'\n      ) {\n        hasUseServer = true;\n      }\n    } else {\n      break;\n    }\n  }\n  if (hasUseServer) {\n    const exportNames = collectExportNames(mod);\n    let newCode = '';\n    for (const name of exportNames) {\n      newCode += `\nexport ${name === 'default' ? name : `const ${name} =`} () => {\n  throw new Error('You cannot call server functions during SSR');\n};\n`;\n    }\n    return swc.transformSync(newCode, {\n      jsc: { parser: parseOpts(ext), target: 'esnext' },\n      sourceMaps: true,\n    });\n  }\n};\n\nexport const createEmptySpan = (): swc.Span =>\n  ({\n    start: 0,\n    end: 0,\n  }) as swc.Span;\n\nconst createIdentifier = (value: string): swc.Identifier => ({\n  type: 'Identifier',\n  value,\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-expect-error\n  ctxt: 0,\n  optional: false,\n  span: createEmptySpan(),\n});\n\nconst createStringLiteral = (value: string): swc.StringLiteral => ({\n  type: 'StringLiteral',\n  value,\n  span: createEmptySpan(),\n});\n\nconst createCallExpression = (\n  callee: swc.Expression,\n  args: swc.Expression[],\n): swc.CallExpression => ({\n  type: 'CallExpression',\n  callee,\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-expect-error\n  ctxt: 0,\n  arguments: args.map((expression) => ({ expression })),\n  span: createEmptySpan(),\n});\n\nconst serverInitCode = swc.parseSync(`\nimport { registerServerReference as __waku_registerServerReference } from 'react-server-dom-webpack/server.edge';\n`).body;\n\nconst findLastImportIndex = (mod: swc.Module) => {\n  const lastImportIndex = mod.body.findIndex(\n    (node) =>\n      node.type !== 'ExpressionStatement' && node.type !== 'ImportDeclaration',\n  );\n  return lastImportIndex === -1 ? 0 : lastImportIndex;\n};\n\nconst replaceNode = <T extends swc.Node>(origNode: swc.Node, newNode: T): T => {\n  Object.keys(origNode).forEach((key) => {\n    delete origNode[key as never];\n  });\n  return Object.assign(origNode, newNode);\n};\n\nconst transformExportedClientThings = (\n  mod: swc.Module,\n  getFuncId: () => string,\n): Set<string> => {\n  const exportNames = new Set<string>();\n  // HACK this doesn't cover all cases\n  const allowServerItems = new Map<string, swc.Expression>();\n  const allowServerDependencies = new Set<string>();\n  const visited = new WeakSet<swc.Node>();\n  const findDependencies = (node: swc.Node) => {\n    if (visited.has(node)) {\n      return;\n    }\n    visited.add(node);\n    if (node.type === 'Identifier') {\n      const id = node as swc.Identifier;\n      if (!allowServerItems.has(id.value) && !exportNames.has(id.value)) {\n        allowServerDependencies.add(id.value);\n      }\n    }\n    Object.values(node).forEach((value) => {\n      (Array.isArray(value) ? value : [value]).forEach((v) => {\n        if (typeof v?.type === 'string') {\n          findDependencies(v);\n        } else if (typeof v?.expression?.type === 'string') {\n          findDependencies(v.expression);\n        }\n      });\n    });\n  };\n  // Pass 1: find allowServer identifier\n  let allowServer = 'unstable_allowServer';\n  for (const item of mod.body) {\n    if (item.type === 'ImportDeclaration') {\n      if (item.source.value === 'waku/client') {\n        for (const specifier of item.specifiers) {\n          if (specifier.type === 'ImportSpecifier') {\n            if (specifier.imported?.value === allowServer) {\n              allowServer = specifier.local.value;\n              break;\n            }\n          }\n        }\n        break;\n      }\n    }\n  }\n  // Pass 2: collect export names and allowServer names\n  for (const item of mod.body) {\n    if (item.type === 'ExportDeclaration') {\n      if (item.declaration.type === 'FunctionDeclaration') {\n        exportNames.add(item.declaration.identifier.value);\n      } else if (item.declaration.type === 'ClassDeclaration') {\n        exportNames.add(item.declaration.identifier.value);\n      } else if (item.declaration.type === 'VariableDeclaration') {\n        for (const d of item.declaration.declarations) {\n          if (d.id.type === 'Identifier') {\n            if (\n              d.init?.type === 'CallExpression' &&\n              d.init.callee.type === 'Identifier' &&\n              d.init.callee.value === allowServer\n            ) {\n              if (d.init.arguments.length !== 1) {\n                throw new Error('allowServer should have exactly one argument');\n              }\n              allowServerItems.set(d.id.value, d.init.arguments[0]!.expression);\n              findDependencies(d.init);\n            } else {\n              exportNames.add(d.id.value);\n            }\n          }\n        }\n      }\n    } else if (item.type === 'ExportNamedDeclaration') {\n      for (const s of item.specifiers) {\n        if (s.type === 'ExportSpecifier') {\n          exportNames.add(s.exported ? s.exported.value : s.orig.value);\n        }\n      }\n    } else if (item.type === 'ExportDefaultExpression') {\n      exportNames.add('default');\n    } else if (item.type === 'ExportDefaultDeclaration') {\n      exportNames.add('default');\n    }\n  }\n  // Pass 3: collect dependencies\n  let dependenciesSize: number;\n  do {\n    dependenciesSize = allowServerDependencies.size;\n    for (const item of mod.body) {\n      if (item.type === 'VariableDeclaration') {\n        for (const d of item.declarations) {\n          if (\n            d.id.type === 'Identifier' &&\n            allowServerDependencies.has(d.id.value)\n          ) {\n            findDependencies(d);\n          }\n        }\n      } else if (item.type === 'FunctionDeclaration') {\n        if (allowServerDependencies.has(item.identifier.value)) {\n          findDependencies(item);\n        }\n      } else if (item.type === 'ClassDeclaration') {\n        if (allowServerDependencies.has(item.identifier.value)) {\n          findDependencies(item);\n        }\n      }\n    }\n  } while (dependenciesSize < allowServerDependencies.size);\n  allowServerDependencies.delete(allowServer);\n  // Pass 4: filter with dependencies\n  for (let i = 0; i < mod.body.length; ++i) {\n    const item = mod.body[i]!;\n    if (\n      item.type === 'ImportDeclaration' &&\n      item.specifiers.some(\n        (s) =>\n          s.type === 'ImportSpecifier' &&\n          allowServerDependencies.has(\n            s.imported ? s.imported.value : s.local.value,\n          ),\n      )\n    ) {\n      continue;\n    }\n    if (item.type === 'VariableDeclaration') {\n      item.declarations = item.declarations.filter(\n        (d) =>\n          d.id.type === 'Identifier' && allowServerDependencies.has(d.id.value),\n      );\n      if (item.declarations.length) {\n        continue;\n      }\n    }\n    if (item.type === 'FunctionDeclaration') {\n      if (allowServerDependencies.has(item.identifier.value)) {\n        continue;\n      }\n    }\n    if (item.type === 'ClassDeclaration') {\n      if (allowServerDependencies.has(item.identifier.value)) {\n        continue;\n      }\n    }\n    mod.body.splice(i--, 1);\n  }\n  // Pass 5: add allowServer exports\n  for (const [allowServerName, callExp] of allowServerItems) {\n    const stmt: swc.ExportDeclaration = {\n      type: 'ExportDeclaration',\n      declaration: {\n        type: 'VariableDeclaration',\n        kind: 'const',\n        declare: false,\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-expect-error\n        ctxt: 0,\n        declarations: [\n          {\n            type: 'VariableDeclarator',\n            id: createIdentifier(allowServerName),\n            init: createCallExpression(\n              createIdentifier('__waku_registerClientReference'),\n              [\n                callExp,\n                createStringLiteral(getFuncId()),\n                createStringLiteral(allowServerName),\n              ],\n            ),\n            definite: false,\n            span: createEmptySpan(),\n          },\n        ],\n        span: createEmptySpan(),\n      },\n      span: createEmptySpan(),\n    };\n    mod.body.push(stmt);\n  }\n  return exportNames;\n};\n\nconst transformExportedServerFunctions = (\n  mod: swc.Module,\n  getFuncId: () => string,\n): boolean => {\n  let changed = false;\n  for (let i = 0; i < mod.body.length; ++i) {\n    const item = mod.body[i]!;\n    const handleDeclaration = (name: string, fn: swc.FunctionDeclaration) => {\n      changed = true;\n      if (fn.body) {\n        fn.body.stmts = fn.body.stmts.filter(\n          (stmt) => !isUseServerDirective(stmt),\n        );\n      }\n      const stmt: swc.ExpressionStatement = {\n        type: 'ExpressionStatement',\n        expression: createCallExpression(\n          createIdentifier('__waku_registerServerReference'),\n          [\n            createIdentifier(name),\n            createStringLiteral(getFuncId()),\n            createStringLiteral(name),\n          ],\n        ),\n        span: createEmptySpan(),\n      };\n      mod.body.splice(++i, 0, stmt);\n    };\n    const handleExpression = (\n      name: string,\n      fn: swc.FunctionExpression | swc.ArrowFunctionExpression,\n    ) => {\n      changed = true;\n      if (fn.body?.type === 'BlockStatement') {\n        fn.body.stmts = fn.body.stmts.filter(\n          (stmt) => !isUseServerDirective(stmt),\n        );\n      }\n      const callExp = createCallExpression(\n        createIdentifier('__waku_registerServerReference'),\n        [\n          Object.assign({}, fn),\n          createStringLiteral(getFuncId()),\n          createStringLiteral(name),\n        ],\n      );\n      replaceNode(fn, callExp);\n    };\n    if (item.type === 'ExportDeclaration') {\n      if (item.declaration.type === 'FunctionDeclaration') {\n        handleDeclaration(item.declaration.identifier.value, item.declaration);\n      } else if (item.declaration.type === 'VariableDeclaration') {\n        for (const d of item.declaration.declarations) {\n          if (\n            d.id.type === 'Identifier' &&\n            (d.init?.type === 'FunctionExpression' ||\n              d.init?.type === 'ArrowFunctionExpression')\n          ) {\n            handleExpression(d.id.value, d.init);\n          }\n        }\n      }\n    } else if (item.type === 'ExportDefaultDeclaration') {\n      if (item.decl.type === 'FunctionExpression') {\n        handleExpression('default', item.decl);\n        const callExp = item.decl;\n        const decl: swc.ExportDefaultExpression = {\n          type: 'ExportDefaultExpression',\n          expression: callExp,\n          span: createEmptySpan(),\n        };\n        replaceNode(item, decl);\n      }\n    } else if (item.type === 'ExportDefaultExpression') {\n      if (\n        item.expression.type === 'FunctionExpression' ||\n        item.expression.type === 'ArrowFunctionExpression'\n      ) {\n        handleExpression('default', item.expression);\n      }\n    }\n  }\n  return changed;\n};\n\ntype FunctionWithBlockBody = (\n  | swc.FunctionDeclaration\n  | swc.FunctionExpression\n  | swc.ArrowFunctionExpression\n) & { body: swc.BlockStatement };\n\nconst isUseServerDirective = (node: swc.Node) =>\n  node.type === 'ExpressionStatement' &&\n  (node as swc.ExpressionStatement).expression.type === 'StringLiteral' &&\n  ((node as swc.ExpressionStatement).expression as swc.StringLiteral).value ===\n    'use server';\n\nconst isInlineServerFunction = (\n  node: swc.Node,\n): node is FunctionWithBlockBody =>\n  (node.type === 'FunctionDeclaration' ||\n    node.type === 'FunctionExpression' ||\n    node.type === 'ArrowFunctionExpression') &&\n  (node as { body?: { type: string } }).body?.type === 'BlockStatement' &&\n  (node as FunctionWithBlockBody).body.stmts.some(isUseServerDirective);\n\nconst prependArgsToFn = <Fn extends FunctionWithBlockBody>(\n  fn: Fn,\n  args: string[],\n): Fn => {\n  if (fn.type === 'ArrowFunctionExpression') {\n    return {\n      ...fn,\n      params: [...args.map(createIdentifier), ...fn.params],\n      body: {\n        type: 'BlockStatement',\n        ctxt: 0,\n        stmts: fn.body.stmts.filter((stmt) => !isUseServerDirective(stmt)),\n        span: createEmptySpan(),\n      },\n    };\n  }\n  return {\n    ...fn,\n    params: [\n      ...args.map((arg) => ({\n        type: 'Parameter',\n        pat: createIdentifier(arg),\n        span: createEmptySpan(),\n      })),\n      ...fn.params,\n    ],\n    body: {\n      type: 'BlockStatement',\n      ctxt: 0,\n      stmts: fn.body.stmts.filter((stmt) => !isUseServerDirective(stmt)),\n      span: createEmptySpan(),\n    },\n  };\n};\n\n// HACK this doesn't work for 100% of cases\nconst collectIndentifiers = (node: swc.Node, ids: Set<string>) => {\n  if (node.type === 'Identifier') {\n    ids.add((node as swc.Identifier).value);\n  } else if (node.type === 'MemberExpression') {\n    collectIndentifiers((node as swc.MemberExpression).object, ids);\n  } else if (node.type === 'KeyValuePatternProperty') {\n    collectIndentifiers((node as swc.KeyValuePatternProperty).key, ids);\n  } else if (node.type === 'AssignmentPatternProperty') {\n    collectIndentifiers((node as swc.AssignmentPatternProperty).key, ids);\n  } else {\n    Object.values(node).forEach((value) => {\n      if (Array.isArray(value)) {\n        value.forEach((v) => collectIndentifiers(v, ids));\n      } else if (typeof value === 'object' && value !== null) {\n        collectIndentifiers(value, ids);\n      }\n    });\n  }\n};\n\n// HACK this doesn't work for 100% of cases\nconst collectLocalNames = (\n  fn: swc.Fn | swc.ArrowFunctionExpression,\n  ids: Set<string>,\n) => {\n  fn.params.forEach((param) => {\n    collectIndentifiers(param, ids);\n  });\n  let stmts: swc.Statement[];\n  if (!fn.body) {\n    stmts = [];\n  } else if (fn.body?.type === 'BlockStatement') {\n    stmts = fn.body.stmts;\n  } else {\n    // body is Expression\n    stmts = [\n      {\n        type: 'ReturnStatement',\n        argument: fn.body,\n        span: createEmptySpan(),\n      },\n    ];\n  }\n  for (const stmt of stmts) {\n    if (stmt.type === 'VariableDeclaration') {\n      for (const decl of stmt.declarations) {\n        collectIndentifiers(decl.id, ids);\n      }\n    }\n  }\n};\n\nconst collectClosureVars = (\n  parentFn: swc.Fn | swc.ArrowFunctionExpression | undefined,\n  fn: FunctionWithBlockBody,\n): string[] => {\n  const parentFnVarNames = new Set<string>();\n  if (parentFn) {\n    collectLocalNames(parentFn, parentFnVarNames);\n  }\n  const fnVarNames = new Set<string>();\n  collectIndentifiers(fn, fnVarNames);\n  const varNames = Array.from(parentFnVarNames).filter((n) =>\n    fnVarNames.has(n),\n  );\n  return varNames;\n};\n\nconst transformInlineServerFunctions = (\n  mod: swc.Module,\n  getFuncId: () => string,\n): boolean => {\n  let serverFunctionIndex = 0;\n  const serverFunctions = new Map<\n    number,\n    readonly [FunctionWithBlockBody, string[]]\n  >();\n  const registerServerFunction = (\n    parentFn: swc.Fn | swc.ArrowFunctionExpression | undefined,\n    fn: FunctionWithBlockBody,\n  ): swc.CallExpression => {\n    const closureVars = collectClosureVars(parentFn, fn);\n    serverFunctions.set(++serverFunctionIndex, [fn, closureVars]);\n    const name = '__waku_func' + serverFunctionIndex;\n    if (fn.type === 'FunctionDeclaration') {\n      fn.identifier = createIdentifier(name);\n    }\n    return createCallExpression(\n      {\n        type: 'MemberExpression',\n        object: createIdentifier(name),\n        property: createIdentifier('bind'),\n        span: createEmptySpan(),\n      },\n      [\n        createIdentifier('null'),\n        ...closureVars.map((v) => createIdentifier(v)),\n      ],\n    );\n  };\n  const handleDeclaration = (\n    parentFn: swc.Fn | swc.ArrowFunctionExpression | undefined,\n    decl: swc.Declaration,\n  ) => {\n    if (isInlineServerFunction(decl)) {\n      const callExp = registerServerFunction(parentFn, Object.assign({}, decl));\n      const newDecl: swc.VariableDeclaration = {\n        type: 'VariableDeclaration',\n        kind: 'const',\n        declare: false,\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-expect-error\n        ctxt: 0,\n        declarations: [\n          {\n            type: 'VariableDeclarator',\n            id: createIdentifier(decl.identifier.value),\n            init: callExp,\n            definite: false,\n            span: createEmptySpan(),\n          },\n        ],\n        span: createEmptySpan(),\n      };\n      replaceNode(decl, newDecl);\n    }\n  };\n  const handleExpression = (\n    parentFn: swc.Fn | swc.ArrowFunctionExpression | undefined,\n    exp: swc.Expression,\n  ): swc.CallExpression | undefined => {\n    if (isInlineServerFunction(exp)) {\n      const callExp = registerServerFunction(parentFn, Object.assign({}, exp));\n      return replaceNode(exp, callExp);\n    }\n  };\n  const walk = (\n    parentFn: swc.Fn | swc.ArrowFunctionExpression | undefined,\n    node: swc.Node,\n  ) => {\n    if (node.type === 'ExportDefaultDeclaration') {\n      const item = node as swc.ExportDefaultDeclaration;\n      if (item.decl.type === 'FunctionExpression') {\n        const callExp = handleExpression(\n          parentFn,\n          item.decl as swc.FunctionExpression,\n        );\n        if (callExp) {\n          const decl: swc.ExportDefaultExpression = {\n            type: 'ExportDefaultExpression',\n            expression: callExp,\n            span: createEmptySpan(),\n          };\n          replaceNode(item, decl);\n          return;\n        }\n      }\n    }\n    // FIXME do we need to walk the entire tree? feels inefficient\n    Object.values(node).forEach((value) => {\n      const fn =\n        node.type === 'FunctionDeclaration' ||\n        node.type === 'FunctionExpression' ||\n        node.type === 'ArrowFunctionExpression'\n          ? (node as swc.Fn | swc.ArrowFunctionExpression)\n          : parentFn;\n      (Array.isArray(value) ? value : [value]).forEach((v) => {\n        if (typeof v?.type === 'string') {\n          walk(fn, v);\n        } else if (typeof v?.expression?.type === 'string') {\n          walk(fn, v.expression);\n        }\n      });\n    });\n    if (node.type === 'FunctionDeclaration') {\n      handleDeclaration(parentFn, node as swc.FunctionDeclaration);\n    } else if (\n      node.type === 'FunctionExpression' ||\n      node.type === 'ArrowFunctionExpression'\n    ) {\n      handleExpression(\n        parentFn,\n        node as swc.FunctionExpression | swc.ArrowFunctionExpression,\n      );\n    }\n  };\n  walk(undefined, mod);\n  if (!serverFunctionIndex) {\n    return false;\n  }\n  const serverFunctionsCode = Array.from(serverFunctions).flatMap(\n    ([funcIndex, [func, closureVars]]) => {\n      if (func.type === 'FunctionDeclaration') {\n        const stmt1: swc.ExportDeclaration = {\n          type: 'ExportDeclaration',\n          declaration: prependArgsToFn(func, closureVars),\n          span: createEmptySpan(),\n        };\n        const stmt2: swc.ExpressionStatement = {\n          type: 'ExpressionStatement',\n          expression: createCallExpression(\n            createIdentifier('__waku_registerServerReference'),\n            [\n              createIdentifier(func.identifier.value),\n              createStringLiteral(getFuncId()),\n              createStringLiteral('__waku_func' + funcIndex),\n            ],\n          ),\n          span: createEmptySpan(),\n        };\n        return [stmt1, stmt2];\n      } else {\n        const stmt: swc.ExportDeclaration = {\n          type: 'ExportDeclaration',\n          declaration: {\n            type: 'VariableDeclaration',\n            kind: 'const',\n            declare: false,\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-expect-error\n            ctxt: 0,\n            declarations: [\n              {\n                type: 'VariableDeclarator',\n                id: createIdentifier('__waku_func' + funcIndex),\n                init: createCallExpression(\n                  createIdentifier('__waku_registerServerReference'),\n                  [\n                    prependArgsToFn(func, closureVars),\n                    createStringLiteral(getFuncId()),\n                    createStringLiteral('__waku_func' + funcIndex),\n                  ],\n                ),\n                definite: false,\n                span: createEmptySpan(),\n              },\n            ],\n            span: createEmptySpan(),\n          },\n          span: createEmptySpan(),\n        };\n        return [stmt];\n      }\n    },\n  );\n  mod.body.splice(findLastImportIndex(mod), 0, ...serverFunctionsCode);\n  return true;\n};\n\nconst transformServer = (\n  code: string,\n  ext: string,\n  getClientId: () => string,\n  getServerId: () => string,\n) => {\n  if (!code.includes('use client') && !code.includes('use server')) {\n    return;\n  }\n  const mod = swc.parseSync(code, parseOpts(ext));\n  let hasUseClient = false;\n  let hasUseServer = false;\n  for (let i = 0; i < mod.body.length; ++i) {\n    const item = mod.body[i]!;\n    if (item.type === 'ExpressionStatement') {\n      if (item.expression.type === 'StringLiteral') {\n        if (item.expression.value === 'use client') {\n          hasUseClient = true;\n          break;\n        } else if (item.expression.value === 'use server') {\n          hasUseServer = true;\n          mod.body.splice(i, 1); // remove this directive\n          break;\n        }\n      }\n    } else {\n      // HACK we can't stop the loop here, because vite may put some import statements before the directives\n      // break;\n    }\n  }\n  if (hasUseClient) {\n    const exportNames = transformExportedClientThings(mod, getClientId);\n    let newCode = `\nimport { registerClientReference as __waku_registerClientReference } from 'react-server-dom-webpack/server.edge';\n`;\n    newCode += swc.printSync(mod).code;\n    for (const name of exportNames) {\n      newCode += `\nexport ${name === 'default' ? name : `const ${name} =`} __waku_registerClientReference(() => { throw new Error('It is not possible to invoke a client function from the server: ${getClientId()}#${name}'); }, '${getClientId()}', '${name}');\n`;\n    }\n    return swc.transformSync(newCode, {\n      jsc: { parser: parseOpts(ext), target: 'esnext' },\n      sourceMaps: true,\n    });\n  }\n  let transformed =\n    hasUseServer && transformExportedServerFunctions(mod, getServerId);\n  transformed = transformInlineServerFunctions(mod, getServerId) || transformed;\n  if (transformed) {\n    mod.body.splice(findLastImportIndex(mod), 0, ...serverInitCode);\n    return swc.printSync(mod, { sourceMaps: true });\n  }\n};\n\nexport function rscTransformPlugin(\n  opts:\n    | {\n        isClient: true;\n        isBuild: false;\n      }\n    | {\n        isClient: true;\n        isBuild: true;\n        serverEntryFiles: Record<string, string>;\n      }\n    | {\n        isClient: false;\n        isBuild: false;\n        resolvedMap: Map<string, string>;\n      }\n    | {\n        isClient: false;\n        isBuild: true;\n        clientEntryFiles: Record<string, string>;\n        serverEntryFiles: Record<string, string>;\n      },\n): Plugin {\n  const getClientId = (id: string): string => {\n    if (opts.isClient) {\n      throw new Error('getClientId is only for server');\n    }\n    if (!opts.isBuild) {\n      return id.split('?')[0]!;\n    }\n    for (const [k, v] of Object.entries(opts.clientEntryFiles)) {\n      if (v === id) {\n        return k;\n      }\n    }\n    throw new Error('client id not found: ' + id);\n  };\n  const getServerId = (id: string): string => {\n    if (!opts.isBuild) {\n      return id.split('?')[0]!;\n    }\n    for (const [k, v] of Object.entries(opts.serverEntryFiles)) {\n      if (v === id) {\n        return k;\n      }\n    }\n    throw new Error('server id not found: ' + id);\n  };\n  return {\n    name: 'rsc-transform-plugin',\n    enforce: 'pre', // required for `resolveId`\n    async resolveId(id, importer, options) {\n      if (opts.isBuild) {\n        return;\n      }\n      if (id.startsWith('/@id/')) {\n        return (await this.resolve(id.slice('/@id/'.length), importer, options))\n          ?.id;\n      }\n      if (id.startsWith('/@fs/')) {\n        return (await this.resolve(id.slice('/@fs'.length), importer, options))\n          ?.id;\n      }\n      if ('resolvedMap' in opts) {\n        const resolved = await this.resolve(id, importer, options);\n        const srcId =\n          importer && (id.startsWith('./') || id.startsWith('../'))\n            ? joinPath(importer.split('?')[0]!, '..', id)\n            : id;\n        const dstId = resolved && resolved.id.split('?')[0]!;\n        if (dstId && dstId !== srcId) {\n          if (!opts.resolvedMap.has(dstId)) {\n            opts.resolvedMap.set(dstId, srcId);\n          }\n        }\n      }\n    },\n    async transform(code, id, options) {\n      const ext = opts.isBuild\n        ? extname(id)\n        : // id can contain query string with vite deps optimization\n          extname(id.split('?')[0]!);\n      if (!EXTENSIONS.includes(ext)) {\n        return;\n      }\n      if (opts.isClient) {\n        if (options?.ssr) {\n          return transformClientForSSR(code, ext);\n        }\n        return transformClient(code, ext, () => getServerId(id));\n      }\n      // isClient === false\n      if (!options?.ssr) {\n        return;\n      }\n      return transformServer(\n        code,\n        ext,\n        () => getClientId(id),\n        () => getServerId(id),\n      );\n    },\n  };\n}\n"],"names":["swc","EXTENSIONS","extname","joinPath","parseOpts","collectExportNames","mod","exportNames","Set","item","body","type","declaration","add","identifier","value","d","declarations","id","s","specifiers","exported","orig","transformClient","code","ext","getServerId","includes","parseSync","hasUseServer","expression","newCode","name","transformSync","jsc","parser","target","sourceMaps","transformClientForSSR","createEmptySpan","start","end","createIdentifier","ctxt","optional","span","createStringLiteral","createCallExpression","callee","args","arguments","map","serverInitCode","findLastImportIndex","lastImportIndex","findIndex","node","replaceNode","origNode","newNode","Object","keys","forEach","key","assign","transformExportedClientThings","getFuncId","allowServerItems","Map","allowServerDependencies","visited","WeakSet","findDependencies","has","values","Array","isArray","v","allowServer","source","specifier","imported","local","init","length","Error","set","dependenciesSize","size","delete","i","some","filter","splice","allowServerName","callExp","stmt","kind","declare","definite","push","transformExportedServerFunctions","changed","handleDeclaration","fn","stmts","isUseServerDirective","handleExpression","decl","isInlineServerFunction","prependArgsToFn","params","arg","pat","collectIndentifiers","ids","object","collectLocalNames","param","argument","collectClosureVars","parentFn","parentFnVarNames","fnVarNames","varNames","from","n","transformInlineServerFunctions","serverFunctionIndex","serverFunctions","registerServerFunction","closureVars","property","newDecl","exp","walk","undefined","serverFunctionsCode","flatMap","funcIndex","func","stmt1","stmt2","transformServer","getClientId","hasUseClient","printSync","transformed","rscTransformPlugin","opts","isClient","isBuild","split","k","entries","clientEntryFiles","serverEntryFiles","enforce","resolveId","importer","options","startsWith","resolve","slice","resolved","srcId","dstId","resolvedMap","transform","ssr"],"mappings":"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"}
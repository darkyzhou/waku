{"version":3,"sources":["../../../src/lib/plugins/vite-plugin-fs-router-typegen.ts"],"sourcesContent":["import type { Plugin } from 'vite';\nimport { readdir, writeFile } from 'node:fs/promises';\nimport { existsSync, readFileSync } from 'node:fs';\nimport { SRC_ENTRIES, EXTENSIONS } from '../builder/constants.js';\nimport { joinPath } from '../utils/path.js';\nimport { isIgnoredPath } from '../utils/fs-router.js';\nimport { getGrouplessPath } from '../utils/create-pages.js';\nimport * as swc from '@swc/core';\n\nconst SRC_PAGES = 'pages';\n\n// https://tc39.es/ecma262/multipage/ecmascript-language-lexical-grammar.html#sec-names-and-keywords\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#identifiers\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#reserved_words\nexport function toIdentifier(input: string): string {\n  // Strip the file extension\n  let identifier = input.includes('.')\n    ? input.split('.').slice(0, -1).join('.')\n    : input;\n  // Replace any characters besides letters, numbers, underscores, and dollar signs with underscores\n  identifier = identifier.replace(/[^\\p{L}\\p{N}_$]/gu, '_');\n  // Ensure it starts with a letter\n  if (/^\\d/.test(identifier)) {\n    identifier = '_' + identifier;\n  }\n  // Turn it into PascalCase\n  // Since the first letter is uppercased, it will not be a reserved word\n  return identifier\n    .split('_')\n    .map((part) => {\n      if (part[0] === undefined) {\n        return '';\n      }\n      return part[0].toUpperCase() + part.slice(1);\n    })\n    .join('');\n}\n\nexport function getImportModuleNames(filePaths: string[]): {\n  [k: string]: string;\n} {\n  const moduleNameCount: { [k: string]: number } = {};\n  const moduleNames: { [k: string]: string } = {};\n  for (const filePath of filePaths) {\n    let identifier = toIdentifier(filePath);\n    moduleNameCount[identifier] = (moduleNameCount[identifier] ?? -1) + 1;\n    if (moduleNameCount[identifier]) {\n      identifier = `${identifier}_${moduleNameCount[identifier]}`;\n    }\n    try {\n      moduleNames[filePath.replace(/^\\//, '')] = identifier;\n    } catch (e) {\n      console.log(e);\n    }\n  }\n  return moduleNames;\n}\n\nexport const fsRouterTypegenPlugin = (opts: { srcDir: string }): Plugin => {\n  let entriesFilePossibilities: string[] | undefined;\n  let pagesDir: string | undefined;\n  let outputFile: string | undefined;\n\n  return {\n    name: 'vite-plugin-fs-router-typegen',\n    apply: 'serve',\n    async configResolved(config) {\n      pagesDir = joinPath(config.root, opts.srcDir, SRC_PAGES);\n      entriesFilePossibilities = EXTENSIONS.map((ext) =>\n        joinPath(config.root, opts.srcDir, SRC_ENTRIES + ext),\n      );\n      outputFile = joinPath(config.root, opts.srcDir, 'pages.gen.ts');\n    },\n    configureServer(server) {\n      if (\n        !entriesFilePossibilities ||\n        !pagesDir ||\n        !outputFile ||\n        entriesFilePossibilities.some((entriesFile) =>\n          existsSync(entriesFile),\n        ) ||\n        !existsSync(pagesDir)\n      ) {\n        return;\n      }\n\n      // Recursively collect `.tsx` files in the given directory\n      const collectFiles = async (\n        dir: string,\n        files: string[] = [],\n      ): Promise<string[]> => {\n        // TODO revisit recursive option for readdir once more stable\n        // https://nodejs.org/docs/latest-v20.x/api/fs.html#direntparentpath\n        const entries = await readdir(dir, { withFileTypes: true });\n        for (const entry of entries) {\n          const fullPath = joinPath(dir, entry.name);\n          if (entry.isDirectory()) {\n            await collectFiles(fullPath, files);\n          } else {\n            if (entry.name.endsWith('.tsx')) {\n              files.push(pagesDir ? fullPath.slice(pagesDir.length) : fullPath);\n            }\n          }\n        }\n        return files;\n      };\n\n      const fileExportsGetConfig = (filePath: string) => {\n        if (!pagesDir) {\n          return false;\n        }\n        const file = swc.parseSync(readFileSync(pagesDir + filePath, 'utf8'), {\n          syntax: 'typescript',\n          tsx: true,\n        });\n\n        return file.body.some((node) => {\n          if (node.type === 'ExportNamedDeclaration') {\n            return node.specifiers.some(\n              (specifier) =>\n                specifier.type === 'ExportSpecifier' &&\n                !specifier.isTypeOnly &&\n                ((!specifier.exported &&\n                  specifier.orig.value === 'getConfig') ||\n                  specifier.exported?.value === 'getConfig'),\n            );\n          }\n\n          return (\n            node.type === 'ExportDeclaration' &&\n            ((node.declaration.type === 'VariableDeclaration' &&\n              node.declaration.declarations.some(\n                (decl) =>\n                  decl.id.type === 'Identifier' &&\n                  decl.id.value === 'getConfig',\n              )) ||\n              (node.declaration.type === 'FunctionDeclaration' &&\n                node.declaration.identifier.value === 'getConfig'))\n          );\n        });\n      };\n\n      const generateFile = (filePaths: string[]): string | null => {\n        const fileInfo: { path: string; src: string; hasGetConfig: boolean }[] =\n          [];\n        const moduleNames = getImportModuleNames(filePaths);\n\n        for (const filePath of filePaths) {\n          // where to import the component from\n          const src = filePath.replace(/^\\//, '');\n          let hasGetConfig = false;\n          try {\n            hasGetConfig = fileExportsGetConfig(filePath);\n          } catch {\n            return null;\n          }\n\n          if (\n            filePath.endsWith('/_layout.tsx') ||\n            isIgnoredPath(filePath.split('/'))\n          ) {\n            continue;\n          } else if (filePath.endsWith('/index.tsx')) {\n            const path = filePath.slice(0, -'/index.tsx'.length);\n            fileInfo.push({\n              path: getGrouplessPath(path) || '/',\n              src,\n              hasGetConfig,\n            });\n          } else {\n            fileInfo.push({\n              path: getGrouplessPath(filePath.replace('.tsx', '')),\n              src,\n              hasGetConfig,\n            });\n          }\n        }\n\n        let result = `// deno-fmt-ignore-file\n// biome-ignore format: generated types do not need formatting\n// prettier-ignore\nimport type { PathsForPages, GetConfigResponse } from 'waku/router';\\n\\n`;\n\n        for (const file of fileInfo) {\n          const moduleName = moduleNames[file.src];\n          if (file.hasGetConfig) {\n            result += `// prettier-ignore\\nimport type { getConfig as ${moduleName}_getConfig } from './${SRC_PAGES}/${file.src.replace('.tsx', '')}';\\n`;\n          }\n        }\n\n        result += `\\n// prettier-ignore\\ntype Page =\\n`;\n\n        for (const file of fileInfo) {\n          const moduleName = moduleNames[file.src];\n          if (file.hasGetConfig) {\n            result += `| ({ path: '${file.path}' } & GetConfigResponse<typeof ${moduleName}_getConfig>)\\n`;\n          } else {\n            result += `| { path: '${file.path}'; render: 'dynamic' }\\n`;\n          }\n        }\n\n        result =\n          result.slice(0, -1) +\n          `;\n\n// prettier-ignore\ndeclare module 'waku/router' {\n  interface RouteConfig {\n    paths: PathsForPages<Page>;\n  }\n  interface CreatePagesConfig {\n    pages: Page;\n  }\n}\n  `;\n\n        return result;\n      };\n\n      const updateGeneratedFile = async () => {\n        if (!pagesDir || !outputFile) {\n          return;\n        }\n        const files = await collectFiles(pagesDir);\n        if (!files.length) {\n          return;\n        }\n        const generation = generateFile(files);\n        if (!generation) {\n          // skip failures\n          return;\n        }\n        await writeFile(outputFile, generation, 'utf-8');\n      };\n\n      server.watcher.on('change', async (file) => {\n        if (!outputFile || outputFile.endsWith(file)) {\n          return;\n        }\n\n        await updateGeneratedFile();\n      });\n      server.watcher.on('add', async (file) => {\n        if (!outputFile || outputFile.endsWith(file)) {\n          return;\n        }\n\n        await updateGeneratedFile();\n      });\n\n      void updateGeneratedFile();\n    },\n  };\n};\n"],"names":["readdir","writeFile","existsSync","readFileSync","SRC_ENTRIES","EXTENSIONS","joinPath","isIgnoredPath","getGrouplessPath","swc","SRC_PAGES","toIdentifier","input","identifier","includes","split","slice","join","replace","test","map","part","undefined","toUpperCase","getImportModuleNames","filePaths","moduleNameCount","moduleNames","filePath","e","console","log","fsRouterTypegenPlugin","opts","entriesFilePossibilities","pagesDir","outputFile","name","apply","configResolved","config","root","srcDir","ext","configureServer","server","some","entriesFile","collectFiles","dir","files","entries","withFileTypes","entry","fullPath","isDirectory","endsWith","push","length","fileExportsGetConfig","file","parseSync","syntax","tsx","body","node","type","specifiers","specifier","isTypeOnly","exported","orig","value","declaration","declarations","decl","id","generateFile","fileInfo","src","hasGetConfig","path","result","moduleName","updateGeneratedFile","generation","watcher","on"],"mappings":"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"}
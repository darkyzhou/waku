{"version":3,"sources":["../../../src/lib/utils/path.ts"],"sourcesContent":["// Terminology:\n// - filePath: posix-like file path, e.g. `/foo/bar.js` or `c:/foo/bar.js`\n//   This is used by Vite.\n// - fileURL: file URL, e.g. `file:///foo/bar.js` or `file:///c:/foo/bar.js`\n//   This is used by import().\n// - osPath: os dependent path, e.g. `/foo/bar.js` or `c:\\foo\\bar.js`\n//   This is used by node:fs.\n\nconst ABSOLUTE_WIN32_PATH_REGEXP = /^\\/[a-zA-Z]:\\//;\n\nexport const encodeFilePathToAbsolute = (filePath: string) => {\n  if (ABSOLUTE_WIN32_PATH_REGEXP.test(filePath)) {\n    throw new Error('Unsupported absolute file path: ' + filePath);\n  }\n  if (filePath.startsWith('/')) {\n    return filePath;\n  }\n  return '/' + filePath;\n};\n\nexport const decodeFilePathFromAbsolute = (filePath: string) => {\n  if (ABSOLUTE_WIN32_PATH_REGEXP.test(filePath)) {\n    return filePath.slice(1);\n  }\n  return filePath;\n};\n\nexport const filePathToFileURL = (filePath: string) =>\n  'file://' + encodeURI(filePath);\n\nexport const fileURLToFilePath = (fileURL: string) => {\n  if (!fileURL.startsWith('file://')) {\n    throw new Error('Not a file URL');\n  }\n  return decodeURI(fileURL.slice('file://'.length));\n};\n\n// for filePath\nexport const joinPath = (...paths: string[]) => {\n  const isAbsolute = paths[0]?.startsWith('/');\n  const items = ([] as string[]).concat(\n    ...paths.map((path) => path.split('/')),\n  );\n  let i = 0;\n  while (i < items.length) {\n    if (items[i] === '.' || items[i] === '') {\n      items.splice(i, 1);\n    } else if (items[i] === '..') {\n      if (i > 0) {\n        items.splice(i - 1, 2);\n        --i;\n      } else {\n        items.splice(i, 1);\n      }\n    } else {\n      ++i;\n    }\n  }\n  return (isAbsolute ? '/' : '') + items.join('/') || '.';\n};\n\nexport const extname = (filePath: string) => {\n  const index = filePath.lastIndexOf('.');\n  if (index <= 0) {\n    return '';\n  }\n  if (['/', '.'].includes(filePath[index - 1]!)) {\n    return '';\n  }\n  return filePath.slice(index);\n};\n\nexport type PathSpecItem =\n  | { type: 'literal'; name: string }\n  | { type: 'group'; name?: string }\n  | { type: 'wildcard'; name?: string };\nexport type PathSpec = readonly PathSpecItem[];\n\nexport const parsePathWithSlug = (path: string): PathSpec =>\n  path\n    .split('/')\n    .filter(Boolean)\n    .map((name) => {\n      let type: 'literal' | 'group' | 'wildcard' = 'literal';\n      const isSlug = name.startsWith('[') && name.endsWith(']');\n      if (isSlug) {\n        type = 'group';\n        name = name.slice(1, -1);\n      }\n      const isWildcard = name.startsWith('...');\n      if (isWildcard) {\n        type = 'wildcard';\n        name = name.slice(3);\n      }\n      return { type, name };\n    });\n\nexport const parseExactPath = (path: string): PathSpec =>\n  path\n    .split('/')\n    .filter(Boolean)\n    .map((name) => ({ type: 'literal', name }));\n\n/**\n * Transform a path spec to a regular expression.\n */\nexport const path2regexp = (path: PathSpec) => {\n  const parts = path.map(({ type, name }) => {\n    if (type === 'literal') {\n      return name;\n    } else if (type === 'group') {\n      return `([^/]+)`;\n    } else {\n      return `(.*)`;\n    }\n  });\n  return `^/${parts.join('/')}$`;\n};\n\n/** Convert a path spec to a string for the path */\nexport const pathSpecAsString = (path: PathSpec) => {\n  return (\n    '/' +\n    path\n      .map(({ type, name }) => {\n        if (type === 'literal') {\n          return name;\n        } else if (type === 'group') {\n          return `[${name}]`;\n        } else {\n          return `[...${name}]`;\n        }\n      })\n      .join('/')\n  );\n};\n\n/**\n * Helper function to get the path mapping from the path spec and the pathname.\n *\n * @param pathSpec\n * @param pathname - route as a string\n * @example\n * getPathMapping(\n *   [\n *     { type: 'literal', name: 'foo' },\n *     { type: 'group', name: 'a' },\n *   ],\n *   '/foo/bar',\n * );\n * // => { a: 'bar' }\n */\nexport const getPathMapping = (\n  pathSpec: PathSpec,\n  pathname: string,\n): Record<string, string | string[]> | null => {\n  const actual = pathname.split('/').filter(Boolean);\n  if (pathSpec.length > actual.length) {\n    return null;\n  }\n  const mapping: Record<string, string | string[]> = {};\n  let wildcardStartIndex = -1;\n  for (let i = 0; i < pathSpec.length; i++) {\n    const { type, name } = pathSpec[i]!;\n    if (type === 'literal') {\n      if (name !== actual[i]) {\n        return null;\n      }\n    } else if (type === 'wildcard') {\n      wildcardStartIndex = i;\n      break;\n    } else if (name) {\n      mapping[name] = actual[i]!;\n    }\n  }\n  if (wildcardStartIndex === -1) {\n    if (pathSpec.length !== actual.length) {\n      return null;\n    }\n    return mapping;\n  }\n  let wildcardEndIndex = -1;\n  for (let i = 0; i < pathSpec.length; i++) {\n    const { type, name } = pathSpec[pathSpec.length - i - 1]!;\n    if (type === 'literal') {\n      if (name !== actual[actual.length - i - 1]) {\n        return null;\n      }\n    } else if (type === 'wildcard') {\n      wildcardEndIndex = actual.length - i - 1;\n      break;\n    } else if (name) {\n      mapping[name] = actual[actual.length - i - 1]!;\n    }\n  }\n  if (wildcardStartIndex === -1 || wildcardEndIndex === -1) {\n    throw new Error('Invalid wildcard path');\n  }\n  const wildcardName = pathSpec[wildcardStartIndex]!.name;\n  if (wildcardName) {\n    mapping[wildcardName] = actual.slice(\n      wildcardStartIndex,\n      wildcardEndIndex + 1,\n    );\n  }\n  return mapping;\n};\n"],"names":["ABSOLUTE_WIN32_PATH_REGEXP","encodeFilePathToAbsolute","filePath","test","Error","startsWith","decodeFilePathFromAbsolute","slice","filePathToFileURL","encodeURI","fileURLToFilePath","fileURL","decodeURI","length","joinPath","paths","isAbsolute","items","concat","map","path","split","i","splice","join","extname","index","lastIndexOf","includes","parsePathWithSlug","filter","Boolean","name","type","isSlug","endsWith","isWildcard","parseExactPath","path2regexp","parts","pathSpecAsString","getPathMapping","pathSpec","pathname","actual","mapping","wildcardStartIndex","wildcardEndIndex","wildcardName"],"mappings":"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"}
{"version":3,"sources":["../../../src/lib/middleware/types.ts"],"sourcesContent":["import type { Config } from '../../config.js';\n\nimport type {\n  EntriesDev,\n  EntriesPrd,\n  HandlerReq,\n  HandlerRes,\n} from '../types.js';\n\nexport type ClonableModuleNode = { url: string; file: string };\n\nexport type HandlerContext = {\n  readonly req: HandlerReq;\n  readonly res: HandlerRes;\n  readonly data: Record<string, unknown>;\n  unstable_devServer?: {\n    rootDir: string;\n    resolveClientEntry: (id: string) => string;\n    loadServerModuleRsc: (idOrFileURL: string) => Promise<Record<string, any>>;\n    loadEntriesDev: (config: { srcDir: string }) => Promise<EntriesDev>;\n    loadServerModuleMain: (idOrFileURL: string) => Promise<Record<string, any>>;\n    transformIndexHtml: (\n      pathname: string,\n    ) => Promise<TransformStream<any, any>>;\n  };\n  unstable_modules?: {\n    rsdwServer: unknown;\n    rdServer: unknown;\n    rsdwClient: unknown;\n    wakuMinimalClient: unknown;\n  };\n};\n\nexport type Handler = (\n  ctx: HandlerContext,\n  next: () => Promise<void>,\n) => Promise<void>;\n\n// This is highly experimental\nexport type ErrorCallback = (\n  err: unknown,\n  ctx: HandlerContext,\n  origin: 'handler' | 'rsc' | 'html',\n) => void;\n\nexport type MiddlewareOptions = {\n  env: Record<string, string>;\n  unstable_onError: Set<ErrorCallback>;\n} & (\n  | { cmd: 'dev'; config: Config }\n  | { cmd: 'start'; loadEntries: () => Promise<EntriesPrd> }\n);\n\nexport type Middleware = (options: MiddlewareOptions) => Handler;\n"],"names":[],"mappings":"AAqDA,WAAiE"}
{"version":3,"sources":["../../../src/lib/hono/engine.ts"],"sourcesContent":["import type { MiddlewareHandler } from 'hono';\n\nimport { resolveConfigDev } from '../config.js';\nimport type { HandlerContext, MiddlewareOptions } from '../middleware/types.js';\n\n// Internal context key\nconst HONO_CONTEXT = '__hono_context';\n\n// serverEngine returns hono middleware that runs Waku middleware.\nexport const serverEngine = (options: MiddlewareOptions): MiddlewareHandler => {\n  const entriesPromise =\n    options.cmd === 'start'\n      ? options.loadEntries()\n      : ('Error: loadEntries are not available' as never);\n  const configPromise =\n    options.cmd === 'start'\n      ? entriesPromise.then((entries) =>\n          // TODO eliminate loadConfig\n          entries.loadConfig().then((config) => resolveConfigDev(config)),\n        )\n      : resolveConfigDev(options.config);\n  const handlersPromise = configPromise.then((config) =>\n    Promise.all(\n      config\n        .middleware()\n        .map(async (middleware) => (await middleware).default(options)),\n    ),\n  );\n  return async (c, next) => {\n    const ctx: HandlerContext = {\n      req: {\n        body: c.req.raw.body,\n        url: new URL(c.req.url),\n        method: c.req.method,\n        headers: c.req.header(),\n      },\n      res: {},\n      context: {\n        [HONO_CONTEXT]: c,\n      },\n      data: {\n        [HONO_CONTEXT]: c,\n      },\n    };\n    const handlers = await handlersPromise;\n    const run = async (index: number) => {\n      if (index >= handlers.length) {\n        return;\n      }\n      let alreadyCalled = false;\n      await handlers[index]!(ctx, async () => {\n        if (!alreadyCalled) {\n          alreadyCalled = true;\n          await run(index + 1);\n        }\n      });\n    };\n    await run(0);\n    if (ctx.res.body || ctx.res.status) {\n      const status = ctx.res.status || 200;\n      const headers = ctx.res.headers || {};\n      if (ctx.res.body) {\n        return c.body(ctx.res.body, status as never, headers);\n      }\n      return c.body(null, status as never, headers);\n    }\n    await next();\n  };\n};\n"],"names":["resolveConfigDev","HONO_CONTEXT","serverEngine","options","entriesPromise","cmd","loadEntries","configPromise","then","entries","loadConfig","config","handlersPromise","Promise","all","middleware","map","default","c","next","ctx","req","body","raw","url","URL","method","headers","header","res","context","data","handlers","run","index","length","alreadyCalled","status"],"mappings":"AAEA,SAASA,gBAAgB,QAAQ,eAAe;AAGhD,uBAAuB;AACvB,MAAMC,eAAe;AAErB,kEAAkE;AAClE,OAAO,MAAMC,eAAe,CAACC;IAC3B,MAAMC,iBACJD,QAAQE,GAAG,KAAK,UACZF,QAAQG,WAAW,KAClB;IACP,MAAMC,gBACJJ,QAAQE,GAAG,KAAK,UACZD,eAAeI,IAAI,CAAC,CAACC,UACnB,4BAA4B;QAC5BA,QAAQC,UAAU,GAAGF,IAAI,CAAC,CAACG,SAAWX,iBAAiBW,YAEzDX,iBAAiBG,QAAQQ,MAAM;IACrC,MAAMC,kBAAkBL,cAAcC,IAAI,CAAC,CAACG,SAC1CE,QAAQC,GAAG,CACTH,OACGI,UAAU,GACVC,GAAG,CAAC,OAAOD,aAAe,AAAC,CAAA,MAAMA,UAAS,EAAGE,OAAO,CAACd;IAG5D,OAAO,OAAOe,GAAGC;QACf,MAAMC,MAAsB;YAC1BC,KAAK;gBACHC,MAAMJ,EAAEG,GAAG,CAACE,GAAG,CAACD,IAAI;gBACpBE,KAAK,IAAIC,IAAIP,EAAEG,GAAG,CAACG,GAAG;gBACtBE,QAAQR,EAAEG,GAAG,CAACK,MAAM;gBACpBC,SAAST,EAAEG,GAAG,CAACO,MAAM;YACvB;YACAC,KAAK,CAAC;YACNC,SAAS;gBACP,CAAC7B,aAAa,EAAEiB;YAClB;YACAa,MAAM;gBACJ,CAAC9B,aAAa,EAAEiB;YAClB;QACF;QACA,MAAMc,WAAW,MAAMpB;QACvB,MAAMqB,MAAM,OAAOC;YACjB,IAAIA,SAASF,SAASG,MAAM,EAAE;gBAC5B;YACF;YACA,IAAIC,gBAAgB;YACpB,MAAMJ,QAAQ,CAACE,MAAM,CAAEd,KAAK;gBAC1B,IAAI,CAACgB,eAAe;oBAClBA,gBAAgB;oBAChB,MAAMH,IAAIC,QAAQ;gBACpB;YACF;QACF;QACA,MAAMD,IAAI;QACV,IAAIb,IAAIS,GAAG,CAACP,IAAI,IAAIF,IAAIS,GAAG,CAACQ,MAAM,EAAE;YAClC,MAAMA,SAASjB,IAAIS,GAAG,CAACQ,MAAM,IAAI;YACjC,MAAMV,UAAUP,IAAIS,GAAG,CAACF,OAAO,IAAI,CAAC;YACpC,IAAIP,IAAIS,GAAG,CAACP,IAAI,EAAE;gBAChB,OAAOJ,EAAEI,IAAI,CAACF,IAAIS,GAAG,CAACP,IAAI,EAAEe,QAAiBV;YAC/C;YACA,OAAOT,EAAEI,IAAI,CAAC,MAAMe,QAAiBV;QACvC;QACA,MAAMR;IACR;AACF,EAAE"}